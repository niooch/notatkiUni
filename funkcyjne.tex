\documentclass[11pt,a4paper]{article}

% Kodowanie i obsługa języka polskiego
\usepackage[utf8]{inputenc}      % Kodowanie wejścia
\usepackage[T1]{fontenc}         % Kodowanie fontów
\usepackage[polish]{babel}       % Obsługa języka polskiego

% Pakiety matematyczne i inne przydatne
\usepackage{amsmath, amssymb, amsthm}  % Pakiety do matematyki
\usepackage{graphicx}                  % Obsługa grafiki
\usepackage{hyperref}                  % Linki i spis treści
\usepackage{geometry}                  % Ustawienie marginesów
\usepackage{algorithm}               % Algorytmy
\usepackage{algpseudocode}           % Pseudokod
\usepackage{fancyvrb}                  % boxy wokol sekcji
\usepackage{listings}               % Kod programu
\geometry{margin=2cm}                  % Ustawienie marginesów na 2 cm

% Dodatkowe ustawienia
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}  % Ustawienia linków
\title{Notatki Programowanie Funkcyjne}
\author{Jakub Kogut}

\begin{document}

\maketitle

\tableofcontents  % Spis treści (opcjonalnie)
\newpage

\section{Wstęp}
Notatki z programowania funkcyjnego prowadzone przez GOATA profesora Jacka Cichonia na semestrze 4 2025. Zajęcia laboratoryjne prowadzone są przez dr Dominika Bojko.

\section{Wykład \date{11-03-2025}}
Na tym wykładzie skupimy się na przygotowaniu środowiska pracy do programowania funkcyjnego w języku Haskell.
\subsection{Struktura kodu w Haskell}
Przykładowy kod wygląda następująco:
\begin{Verbatim}[frame=single]
{-  file = W2.hs
    autor = JK
    date = 11-03-2025
-}
module W2 where
id' x = x
\end{Verbatim}
Następnie w terminalu, w którym mamy odpalone GHCI wpisujemy:
\begin{Verbatim}[frame=single]
>:l W2.hs
>:r
>id' 5
5
>:t id'
id' :: a -> a //co oznacza id :: forall a => a->a
\end{Verbatim}
Co matematycznie można zapisać jako:
\[
    exp=(\lambda a:Typ \rightarrow ( a \rightarrow a))
\]
\begin{itemize}
    \item Przykład:
        \begin{itemize}
            \item $exp(Int)::Int \rightarrow Int$
            \item $exp(Bool)::Bool \rightarrow Bool$
            \item $exp(Double)::Double \rightarrow Double$
        \end{itemize}
\end{itemize}
Cichoń radzi, aby narpiew zastanowić się jaki powinnen być typ funkcji, a dopiero potem zastanawiać się nad implementacją, ponoć oszczędza to \textit{czas i nerwy}.
\subsection{Typy w Haskellu}
\begin{itemize}
    \item Typy proste:
        \begin{itemize}
            \item Int
            \item Double
            \item Char
            \item Bool
        \end{itemize}
    \item Typy złożone:
        \begin{itemize}
            \item Listy
            \item Krotki
            \item Funkcje
        \end{itemize}
\end{itemize}

\begin{itemize}
    \item Przykład:
        \begin{itemize}
            \item funkcja Collatz'a
                $coll::Int \rightarrow Int$
                \begin{Verbatim}[frame=single]
coll n
    | n==1 = 1
    | even n = coll (n `div` 2)
    | odd n = coll (3*n+1)
                \end{Verbatim}
                Symbol \textbf{|} oznacza wyrażenie z wykożystaniem strażników \textit{guards}. Zapis taki jest podobny do matematycznego zapisu funkcji:
                \[
                    coll(n)=\left\{
                        \begin{array}{ll}
                            1 & \text{gdy } n=1 \\
                            coll(\frac{n}{2}) & \text{gdy } n \text{ jest parzyste} \\
                            coll(3n+1) & \text{gdy } n \text{ jest nieparzyste}
                        \end{array}
                    \right.
                \]
                Nie jest to bezpieczna funkcja, ponieważ dla liczb ujemnych zapętli się ona w nieskończoność. \newline
                Można zauważyć, że funkcja ta zwraca zawsze liczbę $1$. Ciekawa jest liczba kroków, które są potrzebne do osiągnięcia tej wartości. Dla $n=27$ potrzeba $111$ kroków, dla $n=28$ potrzeba $18$ kroków, dla $n=29$ potrzeba $111$ kroków.
            \item Nowa funkcja Collatz'a\newline
                collatz::(Int,Int) $\rightarrow$ (Int,Int)
                \begin{Verbatim}[frame=single]
collatz (n,steps)
    | n==1 = (n,steps)
    | even n = collatz (n `div` 2,steps+1)
    | odd n = collatz (3*n+1,steps+1)
                \end{Verbatim}
                Funkcja ta zwraca parę liczb, pierwsza to wynik funkcji Collatz'a, a druga to liczba kroków potrzebna do osiągnięcia tej wartości.\newline
                Spróbujmy ją sobie odpalić:
                \begin{Verbatim}[frame=single]
>collatz (97,0)
(1,118)
                \end{Verbatim}
                Jak widać dla $n=97$ potrzeba $118$ kroków, aby osiągnąć wartość $1$.
            \item Funkcja lenz \textit{lenght of collatz} zwracająca długość ciągu Collatz'a dla danej liczby:\newline
                lenz::Int $\rightarrow$ Int
                \begin{Verbatim}[frame=single]
lenz n = snd (collatz (n,0))
                \end{Verbatim}
        \end{itemize}
\end{itemize}
\subsection{Listy}
Definicja listy w Haskellu:\newline
\text{[a]} - lista elementów typu a
\[
    \text{[a]} = \{[a_1, \dots, a_k] \mid a_1, \dots, a_k \in a, k \in \mathbb{N}\}
\]
\begin{Verbatim}[frame=single]
>:t [1,2,3]
[1,2,3] :: Num a => [a]
>:t [1::Integer, 2, 3]
[1,2,3] :: [Integer]
\end{Verbatim}
\subsubsection{Operacje na listach}
\begin{itemize}
    \item Dodawanie elementu na początku listy
        \begin{Verbatim}[frame=single]
>:t (1:[2,3])
(1:[2,3]) :: Num a => [a]
        \end{Verbatim}
    \item Konkatenacja list
        \begin{Verbatim}[frame=single]
>:t [1,2]++[3,4]
[1,2]++[3,4] :: Num a => [a]
        \end{Verbatim}
\end{itemize}
\subsubsection{Podstawowe funkcje operujace na listach}
\begin{itemize}
    \item length::[a] $\rightarrow$ Int
        \begin{itemize}
            \item length [] = 0
            \item length (x:xs) = 1 + length xs
        \end{itemize}
    \item head::[a] $\rightarrow$ a \newline
        zwraca pierwszy element listy
        \begin{itemize}
            \item head (x:xs) = x
            \item head [] = error "empty list"
        \end{itemize}
    \item tail::[a] $\rightarrow$ [a] \newline
        zwraca listę bez pierwszego elementu
        \begin{itemize}
            \item tail (x:xs) = xs
            \item tail [] = error "empty list"
        \end{itemize}
    \item last::[a] $\rightarrow$ a \newline
        zwraca ostatni element listy
        \begin{itemize}
            \item last [x] = x
            \item last (x:xs) = last xs
            \item last [] = error "empty list"
        \end{itemize}
    \item filter::(a $\rightarrow$ Bool) $\rightarrow$ [a] $\rightarrow$ [a]
        \begin{itemize}
            \item filter p [] = []
            \item filter p (x:xs) = if p x then x : filter p xs else filter p xs
            \item filter ($\lamda$n $\rightarrow$ n>0) [-1,2,-3,4] = [2,4]
            \item filter even [1..10] = [2,4,6,8,10]\newline
                Jak zdefiniować funkcje \textif{filter}:
                \begin{Verbatim}[frame=single]
filter p [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
                \end{Verbatim}
        \end{itemize}
    \item map::(a $\rightarrow$ b) $\rightarrow$ [a] $\rightarrow$ [b] \newline
        zwraca listę, która powstaje zastosowaniem funkcji do każdego elementu listy
        \begin{itemize}
            \item map f [] = []
            \item map f (x:xs) = f x : map f xs
            \item map ($\lamda$n $\rightarrow$ n*n) [1,2,3] = [1,4,9]
            \item map ($\lamda$n $\rightarrow$ $n^3$) [1..10] = [1..1000]
        \end{itemize}
        gdzie \textbf{[1..10]} to skrót od \textbf{[1,2,3,4,5,6,7,8,9,10]}
\end{itemize}

\subsubsection{List comprehension}
Polega na tworzeniu listy na podstawie innych list.
\[
    \boxed{[f x_1, x_2, x_3 \mid x_1 \leftarrow xs, x_2 \leftarrow ys, x_3 \leftarrow zs]}
\]
Przykład:
\begin{itemize}
    \item chcemy stworzyć listę wszystkich trójek pitagorejskich ponizej liczby n.
        \begin{Verbatim}[frame=single]
pitagorasTrzy n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n],
                  x^2 + y^2 == z^2, gcd xy == 1]
        \end{Verbatim}
\end{itemize}



\section{Ćwiczenia}
W tym miejscu będa pojawiały się notatki z laboratorów (ćwiczeń)
\subsection{Ćwiczenia 11-03-2025}
\subsubsection{Zadanie 1}
\begin{Verbatim}[frame=single]
power :: Int => Int => Int
power x y = y ˆ x

p2 = power 4
p3 = power 3
\end{Verbatim}
\begin{enumerate}
    \item Wyznacz w GCHI wartość wyrażenia \( (p2 \circ p3)^2 \) i wyjaśnij, dlaczego otrzymałeś ten wynik.
    \item Zbadaj typy funkcji \( p2 \), \( p3 \) i \( (p2 \circ p3) \).
    \item Zapisz powyższe funkcje za pomocą wyrażeń lambda.
\end{enumerate}
\bigskip
\hrule
\bigskip
\[
    Int \rightarrow Int \rightarrow Int
\]
Zapis strzałkowy definuje nam typ funkcji operacja => jest wiążaca z prawej strony, wiec można by było to również zapisać jako:
\[
    power::Int \rightarrow (Int \rightarrow Int)
\]
\begin{enumerate}
    \item podpunkt 1
\[
    (p2 \circ p3)^2 = p2(p3(x))^2 = 4(3^x)^2 = 4 \cdot 9^x
\]
\item podpunkt 2
    \begin{Verbatim}[frame=single]
>:t p2
p2 :: Int -> Int
>:t p3
p3 :: Int -> Int
>:t (p2 . p3)
(p2 . p3) :: Int -> Int
    \end{Verbatim}
\item podpunkt 3
    \begin{Verbatim}[frame=single]
p2 = \x -> power 4 x
p3 = \x -> power 3 x
    \end{Verbatim}
\end{enumerate}
\subsubsection{Zadanie 2}
\[
2 \wedge 3 \wedge 2, \quad (2 \wedge 3) \wedge 2, \quad 2 \wedge (2 \wedge 3).
\]
Dowiedz się, jaka jest łączność oraz siła operatora \(\wedge\) za pomocą polecenia:
\[
:i (\wedge).
\]
\bigskip
\hrule
\bigskip
\begin{Verbatim}[frame=single]
>:i (^)
(^) :: (Num a, Integral b) => a -> b -> a
        -- Defined in ‘GHC.Real’
infixr 8 ^
\end{Verbatim}
Operator \(\wedge\) jest prawostronnie łączny, a jego siła wynosi 8 (najwyższa możliwa wartość, wyłącznie wyższe jest nałożenie funkcji na zmienną). W nawiasie \textbf{Num a, Integraf b} oznacza, że operator \(\wedge\) bierze jeden argument typu \textbf{Num} i drugi typu \textbf{Integral}.
\[
    2 \wedge 3 \wedge 2 = 2 \wedge (3 \wedge 2) = 2 \wedge 9 = 512
\]
\[
    (2 \wedge 3) \wedge 2 = 8 \wedge 2 = 64
\]
\[
    2 \wedge (2 \wedge 3) = 2 \wedge 8 = 256
\]

\subsubsection{Zadanie 3}
\begin{Verbatim}[frame=single]
f : : Int => Int
f x = x ˆ 2
g : : Int => Int => Int
g x y = x+2*y
h : : . . . .
h x y = f ( g x y )
\end{Verbatim}
\begin{enumerate}
    \item Jaki jest typ funkcji \( h \)? (tzn. uzupełnij \dots\ w powyższym listingu)
    \item Czy \( h = f \circ g \)?
    \item Czy \( h \, x = f(g \, x) \)?
\end{enumerate}
\bigskip
\hrule
\bigskip
\begin{enumerate}
    \item Typ funkcji \( h \) to:
        \[
            h::Int \rightarrow Int \rightarrow Int
        \]
    \item Nie, ponieważ:
        \[
            h(x,y) = f(g(x,y)) = f(x+2y) = (x+2y)^2
        \]
    \item Tak, ponieważ:
        \[
            h(x) = f(g(x)) = f(x+2x) = (x+2x)^2 = 9x^2
        \]
\end{enumerate}

\subsubsection{Zadanie 4}
Zapisz operacje binarne \( (+) \), \( (\ast) \) za pomocą lambda wyrażeń.
\bigskip
\hrule
\bigskip
\begin{Verbatim}[frame=single]
add = \x -> (\y -> x + y)
mul = \x -> (\y -> x * y)
\end{Verbatim}
Co to daje?
Mozna teraz zapisać 2+3 jako:
\begin{itemize}
    \item add 2 3
    \item (add 2) 3
    \item add 2 (3)
    \item (\$3) (2 add)
\end{itemize}

\subsubsection{Zadanie 5}
Zapisz funkcje:

\[
f(x) = 1 + x \cdot (x + 1), \quad g(x, y) = x + y^2, \quad h(y, x) = x + y^2
\]

za pomocą lambda wyrażeń w językach C++, Python, JavaScript oraz Haskell.
\bigskip
\hrule
\bigskip

W języku Haskell:
\begin{Verbatim}[frame=single]
f = \x -> 1 + x * (x + 1)
g = \x -> \y -> x + y^2
h = \y -> \x -> x + y^2
\end{Verbatim}

W języku Python:
\begin{Verbatim}[frame=single]
f = lambda x: 1 + x * (x + 1)
g = lambda x, y: x + y**2
h = lambda y, x: x + y**2
\end{Verbatim}

W języku JavaScript:
\begin{Verbatim}[frame=single]
f = x => 1 + x * (x + 1)
g = (x, y) => x + y**2
h = (y, x) => x + y**2
\end{Verbatim}

W języku C++:
\begin{Verbatim}[frame=single]
auto f = [](int x) { return 1 + x * (x + 1); };
auto g = [](int x, int y) { return x + y*y; };
auto h = [](int y, int x) { return x + y*y; };
\end{Verbatim}

\subsubsection{Zadanie 6}
Ustalmy zbiory \( A, B, C \). Niech

\[
\text{curry} : C^{B \times A} \to (C^B)^A
\]

będzie funkcją zadaną wzorem:

\[
\text{curry}(\varphi) = \lambda a \in A \to (\lambda b \in B \to \varphi(b, a)).
\]

oraz niech

\[
\text{uncurry} : (C^B)^A \to C^{B \times A}
\]

będzie zadana wzorem:

\[
\text{uncurry}(\psi)(b, a) = (\psi(a))(b).
\]

\begin{enumerate}
    \item Pokaż, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \).

    \item Wywnioskuj z tego, że \( |(C^B)^A| = |C^{B \times A}| \). Przypomnij sobie dowód tego twierdzenia, który poznałeś na pierwszym semestrze studiów.

    \item Spróbuj zdefiniować w języku Haskell odpowiedniki funkcji \texttt{curry} i \texttt{uncurry}.
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Pokażemy, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \).
        \begin{itemize}
            \item \( \text{curry} \circ \text{uncurry} \)
                \begin{equation}
                    \begin{aligned}
                        (\text{curry} \circ \text{uncurry})(\psi)
                        &= \text{curry}(\text{uncurry}(\psi)) \\
                        &= \text{curry}(\lambda a \in A \to (\lambda b \in B \to \psi(a)(b))) \\
                        &= \lambda a \in A \to (\lambda b \in B \to \psi(a)(b)).
                    \end{aligned}
                \end{equation}

            \item \( \text{uncurry} \circ \text{curry} \)
                \begin{equation}
                    \begin{aligned}
                        (\text{uncurry} \circ \text{curry})(\varphi)
                        &= \text{uncurry}(\text{curry}(\varphi)) \\
                        &= \text{uncurry}(\lambda a \in A \to (\lambda b \in B \to \varphi(b, a))) \\
                        &= \lambda b \in B \to (\lambda a \in A \to \varphi(b, a)).
                    \end{aligned}
                \end{equation}
        \end{itemize}
        Z powyższych równań wynika, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \). \qed
    \item Możemy pokazać że \texttt{curry} i \texttt{uncurry} są iniekcjami niewprost, nakładając odpowiednio przeciwne funkcje na obie strony równości:
                \begin{itemize}
            \item Załóżmy, że \( \text{curry}(\varphi_1) = \text{curry}(\varphi_2) \). Wtedy:
                \begin{equation}
                    \begin{aligned}
                        \text{curry}(\varphi_1)(a)(b) &= \text{curry}(\varphi_2)(a)(b) \\
                        \varphi_1(b, a) &= \varphi_2(b, a) \\
                        \varphi_1 &= \varphi_2.
                    \end{aligned}
                \end{equation}
            \item Załóżmy, że \( \text{uncurry}(\psi_1) = \text{uncurry}(\psi_2) \). Wtedy:
                \begin{equation}
                    \begin{aligned}
                        \text{uncurry}(\psi_1)(b, a) &= \text{uncurry}(\psi_2)(b, a) \\
                        \psi_1(a)(b) &= \psi_2(a)(b) \\
                        \psi_1 &= \psi_2.
                    \end{aligned}
                \end{equation}
        \end{itemize}
        A więc istnieje biekcja między \( (C^B)^A \) i \( C^{B \times A} \), co oznacza, że te zbiory mają taką samą moc. \qed
    \item W języku Haskell funkcje \texttt{curry} i \texttt{uncurry} można zdefiniować następująco:
        \begin{Verbatim}[frame=single]
curry :: ((b, a) -> c) -> a -> b -> c
curry f x y = f (y, x)
        \end{Verbatim}
        \begin{Verbatim}[frame=single]
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y
        \end{Verbatim}

\end{enumerate}

\subsubsection{Zadanie 7}
Podaj przykłady funkcji następujących typów:
\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow \text{Int}
\]

\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int})
\]

\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int})
\]

\bigskip
\hrule
\bigskip

\begin{itemize}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow \text{Int} \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> Int
f g = g 0
        \end{Verbatim}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> (Int -> Int)
f g x = g (g x)
        \end{Verbatim}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> (Int -> Int) -> (Int -> Int)
f g h x = g (h x)
        \end{Verbatim}
\end{itemize}

\subsubsection{Zadanie 8}
Załóżmy, że chcesz oprogramować funkcję, która dla danych liczb \( a, b \) oraz funkcji \( f: \mathbb{R} \to \mathbb{R} \) oblicza
\[
\int_{a}^{b} f(x) \,dx.
\]
Jaki powinien być typ tej funkcji?

\bigskip
\hrule
\bigskip

Typ tej funkcji powinien być następujący:
\[
    \text{Num(a)} \implies a \rightarrow a \rightarrow (a \rightarrow a) \rightarrow a
\]
mogłaby ona wyglądać następująco:
\begin{Verbatim}[frame=single]
integral :: (Double -> Double) -> Double -> Double -> Double
integral f a b = undefined
\end{Verbatim}

\subsubsection{Zadanie 9 -- (Eliminacja Pętli)}
Wybierz jeden z języków Python, C++ lub JavaScript.

\begin{enumerate}
    \item Masz daną (czyli oprogramowaną) funkcję \( f: \mathbb{N} \to \mathbb{N} \). Oprogramuj funkcję, która dla danego \( n \in \mathbb{N} \) oblicza
    \[
    \sum_{k=0}^{n} f(k).
    \]
    Zrób to najpierw (standardowo) za pomocą pętli, a potem oprogramuj ją bez użycia pętli, za pomocą rekursji.

    \item Rozważamy następującą funkcję napisaną w pseudokodzie:
        \begin{Verbatim}[frame=single]
FUNCTION f(x: DOUBLE): DOUBLE
BEGIN
    DOUBLE y = sin(x);
    RETURN y*y + y + x;
ENDFNC
        \end{Verbatim}

    Oprogramuj tę funkcję w wybranym języku i następnie wyeliminuj zmienną lokalną \( y \) z tego kodu, bez pogarszania jego efektywności.
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Oto rozwiązanie w języku C++:
        \begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

// Example implementation of function f: N -> N.
// You can replace this with any function of type int -> int.
int f(int x) {
    // Example: f(x) = x + 1
    return x + 1;
}

// Function that sums using a loop:
int sumLoop(int n) {
    int sum = 0;
    for (int k = 0; k <= n; ++k) {
        sum += f(k);
    }
    return sum;
}

// Function that sums using recursion:
int sumRec(int n) {
    if(n == 0)
        return f(0);
    else
        return sumRec(n - 1) + f(n);
}

int main() {
    int n;
    cout << "Enter n: ";
    cin >> n;
    cout << "Sum computed with loop: " << sumLoop(n) << endl;
    cout << "Sum computed recursively: " << sumRec(n) << endl;
    return 0;
}
\end{lstlisting}
    funkcja \texttt{sumLoop} oblicza sumę za pomocą pętli, a funkcja \texttt{sumRec} oblicza sumę rekurencyjnie.
    \[
        \text{sumRec}(n) = \left\{
            \begin{array}{ll}
                f(0) & \text{gdy } n = 0 \\
                \text{sumRec}(n-1) + f(n) & \text{gdy } n > 0
            \end{array}
        \right.
    \]
\item Rozwiazanie w Haskellu:
    \begin{Verbatim}[frame=single]
f :: Double -> Double
f x = sin x * sin x + sin x + x
    \end{Verbatim}
    \begin{Verbatim}[frame=single]
f' :: Double -> Double
f' x = sin x * sin x + sin x + x
    \end{Verbatim}
\end{enumerate}

\subsubsection{Zadanie 10}
Zaimplementuj samodzielnie następujące funkcje działające na listach z Prelude:
\begin{enumerate}
    \item map
    \item zip
    \item zipWith
    \item filter
    \item take
    \item drop
    \item fib
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Funkcja \texttt{map}:
        \begin{Verbatim}[frame=single]
map' :: (a -> b) -> [a] -> [b]
map' f [] = []
map' f (x:xs) = f x : map' f xs
        \end{Verbatim}
    \item Funkcja \texttt{zip}\footnote{Funkcja \texttt{zip} zwraca listę par, które są złożone z elementów listy wejściowej.
        Jeśli jedna z list jest krótsza, to wynikowa lista będzie miała długość krótszej z nich. \newline
    Przykład: \texttt{zip [1,2,3] ['a','b','c','d']} zwróci \texttt{[(1,'a'),(2,'b'),(3,'c')]}.}:
        \begin{Verbatim}[frame=single]
zip' :: [a] -> [b] -> [(a, b)]
zip' [] _ = []
zip' _ [] = []
zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
        \end{Verbatim}
    \item Funkcja \texttt{zipWith}\footnote{Funkcja \texttt{zipWith} działa podobnie jak \texttt{zip}, ale zamiast zwracać parę elementów, zwraca wynik funkcji, która jest podana jako argument. \newline
        Przykład: \texttt{zipWith (+) [1,2,3] [4,5,6]} zwróci \texttt{[5,7,9]}.}:
        \begin{Verbatim}[frame=single]
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
        \end{Verbatim}
    \item Funkcja \texttt{filter}\footnote{Funkcja \texttt{filter} zwraca listę elementów, które spełniają warunek podany jako argument. \newline
        Przykład: \texttt{filter even [1..10]} zwróci \texttt{[2,4,6,8,10]}.}:
        \begin{Verbatim}[frame=single]
filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
    | p x = x : filter' p xs
    | otherwise = filter' p xs
        \end{Verbatim}
    \item Funkcja \texttt{take}\footnote{Funkcja \texttt{take} zwraca listę składającą się z \( n \) pierwszych elementów listy wejściowej. \newline
        Przykład: \texttt{take 3 [1,2,3,4,5]} zwróci \texttt{[1,2,3]}.}:
        \begin{Verbatim}[frame=single]
take' :: Int -> [a] -> [a]
take' 0 _ = []
take' _ [] = []
take' n (x:xs) = x : take' (n - 1) xs
        \end{Verbatim}
    \item Funkcja \texttt{drop}\footnote{Funkcja \texttt{drop} zwraca listę, która jest wynikiem usunięcia \( n \) pierwszych elementów z listy wejściowej. \newline
        Przykład: \texttt{drop 3 [1,2,3,4,5]} zwróci \texttt{[4,5]}.}:
        \begin{Verbatim}[frame=single]
drop' :: Int -> [a] -> [a]
drop' 0 xs = xs
drop' _ [] = []
drop' n (_:xs) = drop' (n - 1) xs
        \end{Verbatim}
    \item Funkcja \texttt{fib}\footnote{Funkcja \texttt{fib} zwraca listę liczb Fibonacciego do \( n \)-tego elementu.}:
        \begin{Verbatim}[frame=single]
fib :: Int -> [Int]
fib n = take' n (map' fib' [0..])
    where
        fib' 0 = 0
        fib' 1 = 1
        fib' n = fib (n - 1) + fib (n - 2)
        \end{Verbatim}
\end{enumerate}
Fajne złożenie funkcji \texttt{fib} z \texttt{zipWith}:
\begin{Verbatim}[frame=single]
fib :: [Int]
fib = 0 : 1 : zipWith (+) fib (tail fib)
\end{Verbatim}
co pozwala na generowanie listy liczb Fibonacciego w nieskończoność.
Na przykład \texttt{take 10 fib} zwróci \texttt{[0,1,1,2,3,5,8,13,21,34]}.

\subsubsection{Zadanie 11}
Niech \( f = (2^{\wedge}) \) oraz \( g = (\wedge 2) \). Podaj interpretację tych funkcji.

Sprawdź wartości wyrażenia:
\[
\text{map } (\wedge 2) [1..10] \quad \text{oraz} \quad \text{map } (2^{\wedge}) [1..10]
\]
i wyjaśnij otrzymane wyniki.

\bigskip
\hrule
\bigskip

Funkcja \( f = (2 \, \wedge) \) podnosi liczbę do kwadratu, a funkcja \( g = (\wedge \, 2) \) podnosi 2 do potęgi danej liczby.
\begin{Verbatim}[frame=single]
> map (^ 2) [1..10]
[1,4,9,16,25,36,49,64,81,100]
> map (2 ^) [1..10]
[2,4,8,16,32,64,128,256,512,1024]
\end{Verbatim}

\subsubsection{Zadanie 12}
Dowiedz się, jak można przekonwertować elementy typu \texttt{Int} oraz \texttt{Integer} na typy \texttt{Float} i \texttt{Double}. Dowiedz się, jaki jest format funkcji typu \texttt{round} z \texttt{Double} do \texttt{Int}.

\bigskip
\hrule
\bigskip

\begin{itemize}
    \item Konwersja z \texttt{Int} na \texttt{Float}:
        \begin{Verbatim}[frame=single]
fromIntegral :: (Integral a, Num b) => a -> b
        \end{Verbatim}
    \item Konwersja z \texttt{Int} na \texttt{Double}:
        \begin{Verbatim}[frame=single]
fromIntegral :: (Integral a, Num b) => a -> b
        \end{Verbatim}
    \item Konwersja z \texttt{Integer} na \texttt{Float}:
        \begin{Verbatim}[frame=single]
fromInteger :: Num a => Integer -> a
        \end{Verbatim}
    \item Konwersja z \texttt{Integer} na \texttt{Double}:
        \begin{Verbatim}[frame=single]
fromInteger :: Num a => Integer -> a
        \end{Verbatim}
    \item Funkcja \texttt{round} z \texttt{Double} na \texttt{Int}:
        \begin{Verbatim}[frame=single]
round :: (RealFrac a, Integral b) => a -> b
        \end{Verbatim}
\end{itemize}

\subsection{Elementy Teorii Liczb}
Trochę teorii liczb, bo czemu nie?
\subsubsection{Zadanie 13}
Funkcję Eulera \(\varphi\) nazywamy funkcją określoną wzorem:
\begin{equation}
    \varphi(n) = \text{card}\left(\{k \leq n : \gcd(k, n) = 1\}\right),
\end{equation}
o dziedzinie \(\mathbb{N}^+\).
\begin{enumerate}
    \item Oprogramuj funkcję \(\varphi\) (funkcja \(\gcd\) jest dostępna w bibliotece \texttt{Prelude}).
    \item Napisz funkcję, która dla danej liczby naturalnej \(n\) wyznacza sumę:
        \[
            \sum_{k \mid n} \varphi(k).
        \]
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Oto implementacja funkcji \(\varphi\) w języku Haskell:
        \begin{Verbatim}[frame=single]
phi :: Int -> Int
phi n = length [k | k <- [1..n], gcd k n == 1]

> phi 10
4
        \end{Verbatim}
    \item Oto implementacja funkcji, która wyznacza sumę \(\sum_{k \mid n} \varphi(k)\):
        \begin{Verbatim}[frame=single]
sumPhi :: Int -> Int
sumPhi n = sum [phi k | k <- [1..n], n `mod` k == 0]

> sumPhi 10
10
        \end{Verbatim}
\end{enumerate}

\subsubsection{Zadanie 14}
Liczbę naturalną \(n\) nazywamy \textit{doskonałą}, jeżeli spełnia warunek:
\begin{equation}
    n = \sum \{ d : 1 \leq d < n \land d \mid n \}.
\end{equation}

Na przykład liczba \(6\) jest liczbą doskonałą, ponieważ:
\begin{equation}
    6 = 1 + 2 + 3.
\end{equation}

Wyznacz wszystkie liczby doskonałe mniejsze od \(10\,000\).

\textbf{Uwaga:} Do tej pory nie wiadomo, czy istnieje nieskończenie wiele liczb doskonałych.

\bigskip
\hrule
\bigskip

Oto implementacja funkcji, która znajduje wszystkie liczby doskonałe mniejsze od \(10\,000\):
\begin{Verbatim}[frame=single]
isPerfect :: Int -> Bool
isPerfect n = n == sum [d | d <- [1..n-1], n `mod` d == 0]

perfectNumbers :: [Int]
perfectNumbers = [n | n <- [1..9999], isPerfect n]

> perfectNumbers
[6,28,496,8128]
\end{Verbatim}

\subsubsection{Zadanie 15}
Parę liczb naturalnych \((m, n)\) nazywamy \textit{zaprzyjaźnionymi}, jeżeli suma dzielników właściwych każdej z nich równa się drugiej:
\[
    \sigma(m) - m = n, \quad \sigma(n) - n = m,
\]
gdzie \(\sigma(n)\) oznacza sumę wszystkich dzielników liczby \(n\).

Znajdź wszystkie zaprzyjaźnione pary, których oba składniki są mniejsze od \(10^5\).

\textbf{Uwaga:} Do tej pory nie wiadomo, czy istnieje nieskończenie wiele par liczb zaprzyjaźnionych.

\bigskip
\hrule
\bigskip

Tak może wyglądać funkcja szukająca liczb zaprzyjaźnionych w podanym zakresie:
\begin{Verbatim}[frame=single]
sumaDzielnikow :: Int -> Int
sumaDzielnikow 1 = 0
sumaDzielnikow n = 1 + sum [ if x * x == n then x
                            else if n `mod` x == 0 then x + (n `div` x)
                            else 0
                            | x <- [2..(floor . sqrt . fromIntegral) n], x * x <= n ]
    where
        limit = (floor . sqrt . fromIntegral) n

amicablePairs :: [(Int, Int)]
amicablePairs = [ (n, m)
                | n <- [2..maxVal-1]
                , let m = sumaDzielnikow n
                , m > n, m < maxVal
                , sumaDzielnikow m == n ]

> amicablePairs
%TODO niech się policzy
\end{Verbatim}

\subsubsection{Zadanie 16}
Dla \(n \in \mathbb{N}^+\) definiujemy:
\begin{equation}
    \text{dcp}(n) = \frac{1}{2 n^2} \left| \{(k, l) \in \{1, \dots, n\} : \gcd(k, l) = 1\} \right|.
\end{equation}

\begin{enumerate}
    \item Zaimplementuj tę funkcję w języku Haskell za pomocą \textit{list comprehension}.
    \item Zoptymalizuj ten kod, pisząc rekurencyjną wersję tej funkcji.
    \item Wyznacz wartości tej funkcji dla \(n = 100, 200, 300, \dots, 10000\) i postaw jaką rozsądną hipotezę o:
        \begin{equation}
            \lim\limits_{n \to \infty} \text{dcp}(n).
        \end{equation}
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Przykładowa implementacja przy użyciu \textit{list comprehension}:
        \begin{Verbatim}[frame=single]
dcp :: Int -> Double
dcp n = 1 / (2 * fromIntegral (n^2))
        * fromIntegral (length [(k, l)
                                | k <- [1..n], l <- [1..n], gcd k l == 1])

> dcp 10
0.315
        \end{Verbatim}
    \item Optymalizacja kodu przy użyciu rekurencji:
        \begin{Verbatim}[frame=single]
dcp' :: Int -> Double
dcp' n = 1 / (2 * fromIntegral (n^2)) * fromIntegral (dcp'' n 1 1)

dcp'' :: Int -> Int -> Int -> Int
dcp'' n k l
    | k > n     = 0
    | l > n     = dcp'' n (k + 1) 1
    | gcd k l == 1 = 1 + dcp'' n k (l + 1)
    | otherwise = dcp'' n k (l + 1)

> dcp' 10
0.315
        \end{Verbatim}
    \item Wyznaczenie wartości funkcji dla \(n = 100, 200, 300, \dots, 10000\):
        \begin{Verbatim}[frame=single]
dcpValues :: [Double]
dcpValues = [dcp' n | n <- [100, 200..10000]]

> dcpValues
[0.30435,0.3057875,0.30441666666666667,0.304234375,0.304462,
0.3041652777777778,0.3041173469387755,0.30429609375,0.3041055555555556,
0.3041915,0.3042293388429752,0.30401770833333336,0.30404940828402366,
0.30412627551020405,0.30408066666666667,0.3039966796875,
0.3041839100346021,0.3040300925925926,0.3040048476454294,0.304146875,
0.304041156462585,0.3039759297520661,0.30407854442344046,
0.3040509548611111,0.3039804,0.3040543639053254,0.3040213305898491,
0.30399381377551016,0.3040546373365042,0.30402083333333335,
0.3040220083246618,0.304030029296875,0.3039801193755739,
0.30399476643598616,0.30402542857142856,0.30400150462962966,
0.30400697589481374,0.30404456371191135,0.30397827087442475,
0.30397509375,0.3040405413444378,0.30397174036281177,
0.30401695511087073,0.3040362345041322,0.3039997777777778,
0.30397993856332706,0.3040101177003169,*** Exception: stack overflow
        \end{Verbatim}
        Na podstawie uzyskanych wartości można postawić hipotezę, że granica funkcji \(\text{dcp}(n)\) dla \(n \to \infty\) wynosi około \(0.304\). Wartość ta może być przybliżona do wartości funkcji Eulera \(\frac{6}{\pi^2}\). \qed
\end{enumerate}

\subsection{Listy -- część 1.}
Na początku tych zadań należało zastanowić się nad implementacją istniejących już funkcji z Prelude, a następnie zaimplementować je samodzielnie.

\end{document}
