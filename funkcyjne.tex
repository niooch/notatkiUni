\documentclass[11pt,a4paper]{article}

% Kodowanie i obsługa języka polskiego
\usepackage[utf8]{inputenc}      % Kodowanie wejścia
\usepackage[T1]{fontenc}         % Kodowanie fontów
\usepackage[polish]{babel}       % Obsługa języka polskiego

% Pakiety matematyczne i inne przydatne
\usepackage{tikz}
\usetikzlibrary{automata, positioning}
\usepackage{amsmath, amssymb, amsthm}  % Pakiety do matematyki
\usepackage{graphicx}                  % Obsługa grafiki
\usepackage{hyperref}                  % Linki i spis treści
\usepackage{geometry}                  % Ustawienie marginesów
\usepackage{algorithm}               % Algorytmy
\usepackage{algpseudocode}           % Pseudokod
\usepackage{fancyvrb}                  % boxy wokol sekcji
\usepackage{listings}               % Kod programu
\geometry{margin=2cm}                  % Ustawienie marginesów na 2 cm

% Dodatkowe ustawienia
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}  % Ustawienia linków
\title{Notatki Programowanie Funkcyjne}
\author{Jakub Kogut}

\begin{document}

\maketitle

\tableofcontents  % Spis treści (opcjonalnie)
\newpage

\section{Wstęp}
Notatki z programowania funkcyjnego prowadzone przez GOATA profesora Jacka Cichonia na semestrze 4 2025. Zajęcia laboratoryjne prowadzone są przez dr Dominika Bojko.

\section{Wykład \date{11-03-2025}}
Na tym wykładzie skupimy się na przygotowaniu środowiska pracy do programowania funkcyjnego w języku Haskell.
\subsection{Struktura kodu w Haskell}
Przykładowy kod wygląda następująco:
\begin{Verbatim}[frame=single]
{-  file = W2.hs
    autor = JK
    date = 11-03-2025
-}
module W2 where
id' x = x
\end{Verbatim}
Następnie w terminalu, w którym mamy odpalone GHCI wpisujemy:
\begin{Verbatim}[frame=single]
>:l W2.hs
>:r
>id' 5
5
>:t id'
id' :: a -> a //co oznacza id :: forall a => a->a
\end{Verbatim}
Co matematycznie można zapisać jako:
\[
    exp=(\lambda a:Typ \rightarrow ( a \rightarrow a))
\]
\begin{itemize}
    \item Przykład:
        \begin{itemize}
            \item $exp(Int)::Int \rightarrow Int$
            \item $exp(Bool)::Bool \rightarrow Bool$
            \item $exp(Double)::Double \rightarrow Double$
        \end{itemize}
\end{itemize}
Cichoń radzi, aby narpiew zastanowić się jaki powinnen być typ funkcji, a dopiero potem zastanawiać się nad implementacją, ponoć oszczędza to \textit{czas i nerwy}.
\subsection{Typy w Haskellu}
\begin{itemize}
    \item Typy proste:
        \begin{itemize}
            \item Int
            \item Double
            \item Char
            \item Bool
        \end{itemize}
    \item Typy złożone:
        \begin{itemize}
            \item Listy
            \item Krotki
            \item Funkcje
        \end{itemize}
\end{itemize}

\begin{itemize}
    \item Przykład:
        \begin{itemize}
            \item funkcja Collatz'a
                $coll::Int \rightarrow Int$
                \begin{Verbatim}[frame=single]
coll n
    | n==1 = 1
    | even n = coll (n `div` 2)
    | odd n = coll (3*n+1)
                \end{Verbatim}
                Symbol \textbf{|} oznacza wyrażenie z wykożystaniem strażników \textit{guards}. Zapis taki jest podobny do matematycznego zapisu funkcji:
                \[
                    coll(n)=\left\{
                        \begin{array}{ll}
                            1 & \text{gdy } n=1 \\
                            coll(\frac{n}{2}) & \text{gdy } n \text{ jest parzyste} \\
                            coll(3n+1) & \text{gdy } n \text{ jest nieparzyste}
                        \end{array}
                    \right.
                \]
                Nie jest to bezpieczna funkcja, ponieważ dla liczb ujemnych zapętli się ona w nieskończoność. \newline
                Można zauważyć, że funkcja ta zwraca zawsze liczbę $1$. Ciekawa jest liczba kroków, które są potrzebne do osiągnięcia tej wartości. Dla $n=27$ potrzeba $111$ kroków, dla $n=28$ potrzeba $18$ kroków, dla $n=29$ potrzeba $111$ kroków.
            \item Nowa funkcja Collatz'a\newline
                collatz::(Int,Int) $\rightarrow$ (Int,Int)
                \begin{Verbatim}[frame=single]
collatz (n,steps)
    | n==1 = (n,steps)
    | even n = collatz (n `div` 2,steps+1)
    | odd n = collatz (3*n+1,steps+1)
                \end{Verbatim}
                Funkcja ta zwraca parę liczb, pierwsza to wynik funkcji Collatz'a, a druga to liczba kroków potrzebna do osiągnięcia tej wartości.\newline
                Spróbujmy ją sobie odpalić:
                \begin{Verbatim}[frame=single]
>collatz (97,0)
(1,118)
                \end{Verbatim}
                Jak widać dla $n=97$ potrzeba $118$ kroków, aby osiągnąć wartość $1$.
            \item Funkcja lenz \textit{lenght of collatz} zwracająca długość ciągu Collatz'a dla danej liczby:\newline
                lenz::Int $\rightarrow$ Int
                \begin{Verbatim}[frame=single]
lenz n = snd (collatz (n,0))
                \end{Verbatim}
        \end{itemize}
\end{itemize}
\subsection{Listy}
Definicja listy w Haskellu:\newline
\text{[a]} - lista elementów typu a
\[
    \text{[a]} = \{[a_1, \dots, a_k] \mid a_1, \dots, a_k \in a, k \in \mathbb{N}\}
\]
\begin{Verbatim}[frame=single]
>:t [1,2,3]
[1,2,3] :: Num a => [a]
>:t [1::Integer, 2, 3]
[1,2,3] :: [Integer]
\end{Verbatim}
\subsubsection{Operacje na listach}
\begin{itemize}
    \item Dodawanie elementu na początku listy
        \begin{Verbatim}[frame=single]
>:t (1:[2,3])
(1:[2,3]) :: Num a => [a]
        \end{Verbatim}
    \item Konkatenacja list
        \begin{Verbatim}[frame=single]
>:t [1,2]++[3,4]
[1,2]++[3,4] :: Num a => [a]
        \end{Verbatim}
\end{itemize}
\subsubsection{Podstawowe funkcje operujace na listach}
\begin{itemize}
    \item length::[a] $\rightarrow$ Int
        \begin{itemize}
            \item length [] = 0
            \item length (x:xs) = 1 + length xs
        \end{itemize}
    \item head::[a] $\rightarrow$ a \newline
        zwraca pierwszy element listy
        \begin{itemize}
            \item head (x:xs) = x
            \item head [] = error "empty list"
        \end{itemize}
    \item tail::[a] $\rightarrow$ [a] \newline
        zwraca listę bez pierwszego elementu
        \begin{itemize}
            \item tail (x:xs) = xs
            \item tail [] = error "empty list"
        \end{itemize}
    \item last::[a] $\rightarrow$ a \newline
        zwraca ostatni element listy
        \begin{itemize}
            \item last [x] = x
            \item last (x:xs) = last xs
            \item last [] = error "empty list"
        \end{itemize}
    \item filter::(a $\rightarrow$ Bool) $\rightarrow$ [a] $\rightarrow$ [a]
        \begin{itemize}
            \item filter p [] = []
            \item filter p (x:xs) = if p x then x : filter p xs else filter p xs
            \item filter ($\lamda$n $\rightarrow$ n>0) [-1,2,-3,4] = [2,4]
            \item filter even [1..10] = [2,4,6,8,10]\newline
                Jak zdefiniować funkcje \textif{filter}:
                \begin{Verbatim}[frame=single]
filter p [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
                \end{Verbatim}
        \end{itemize}
    \item map::(a $\rightarrow$ b) $\rightarrow$ [a] $\rightarrow$ [b] \newline
        zwraca listę, która powstaje zastosowaniem funkcji do każdego elementu listy
        \begin{itemize}
            \item map f [] = []
            \item map f (x:xs) = f x : map f xs
            \item map ($\lamda$n $\rightarrow$ n*n) [1,2,3] = [1,4,9]
            \item map ($\lamda$n $\rightarrow$ $n^3$) [1..10] = [1..1000]
        \end{itemize}
        gdzie \textbf{[1..10]} to skrót od \textbf{[1,2,3,4,5,6,7,8,9,10]}
\end{itemize}

\subsubsection{List comprehension}
Polega na tworzeniu listy na podstawie innych list.
\[
    \boxed{[f x_1, x_2, x_3 \mid x_1 \leftarrow xs, x_2 \leftarrow ys, x_3 \leftarrow zs]}
\]
Przykład:
\begin{itemize}
    \item chcemy stworzyć listę wszystkich trójek pitagorejskich ponizej liczby n.
        \begin{Verbatim}[frame=single]
pitagorasTrzy n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n],
                  x^2 + y^2 == z^2, gcd xy == 1]
        \end{Verbatim}
\end{itemize}


\section{Wykład \date{18-03-2025}}
\subsection{implementacje funkcji w Haskellu}
\subsubsection{QuickSort}
w tej implementacji za \textit{pivot} przyjmujemy pierwszy element listy.
\begin{Verbatim}[frame=single]
qS [] = []
qs (x:xs) = (qS [y | y <- xs, y < x]) ++
            [x] ++
            (qS [y | y <- xs, y >= x])
\end{Verbatim}

\subsubsection{\textit{partition}}
\begin{Verbatim}[frame=single]
partition :: (a->Bool) -> [a] -> ([a],[a])
partition _ [] = ([],[])
partition p (x:xs) = if p x then (x:l,r)
                            else (l,x:r)
                    where (l,r) = partition p xs
\end{Verbatim}

\subsubsection{Lepsza implementacja QuickSort'a}
\begin{Verbatim}[frame=single]
qSort [] = []
qSort (x:xs) = (qSort l) ++ [x] ++ (qSort r)
               where (l,r) = partition (<x) xs
\end{Verbatim}
wyrażenie \texttt{(<x)} jest zastosowaniem \textit{slicingu}. Działa to następująco:
\[
    (<x) \equiv \lambda y \rightarrow y < x
\]

\subsubsection{InsertSort}
\begin{Verbatim}[frame=single]
inSort [] = []
inSort (x:xs) = l ++ [x] ++ r
                where sxs = inSort xs
                      (l,r) = partition (<x) sxs
\end{Verbatim}

Aby sprawdzić prędkość wykonywania funkcji w Haskellu możemy użyć następującej funkcji
\begin{Verbatim}[frame=single]
>:set +s
>take 10 (inSort [1000,999..1])
[1,2,3,4,5,6,7,8,9,10]
(0.02 secs, 5,499,824 bytes)
\end{Verbatim}

\subsubsection{\textit{zip}}
Powtórka z ćwiczen \textit{Zadanie 10} \ref{zadanie10}
\subsubsection{\textit{zipWith}}
Podobnie znowu napisane na ćwiczeniach \ref{zadanie10}

\subsubsection{funkcje wykonujące operacje na listach}
funkcja sumująca:
\begin{Verbatim}[frame=single]
sumList [] = 0
sumList (x:xs) = x + sumList xs

> sumList [1..1000]
500500
\end{Verbatim}

funkcja mnożąca:
\begin{Verbatim}[frame=single]
pro [] = 1
pro (x:xs) = x * pro xs

>pro [1..9]
362880
\end{Verbatim}

teraz abstrachując ten koncept możemy napisać funkcję \textit{foldl}\footnote{jest to operacja składająca liste w nastepujący sposób $(((e \cdot x_1) \cdot x_2 ) \cdot x_3 ) \cdot \dots ) \cdot x_n$, istneje analogiczna \textit{foldr} działająca odwrotnie $x_1 \cdot (x_2 \cdot (x_3 \cdot \dots (x_n \cdot e)))$}, która działa na danym monoidzie $M=(M,\cdot,e)$
\begin{Verbatim}[frame=single]
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl' op e [] = e
foldl' op e (x:xs) = op x (foldl' op e xs)

ghci> foldl' (*) 1 [1..10]
3628800
ghci> foldl' (+) 1 [1..10]
56
ghci> foldl' (+) 0 [1..10]
55
ghci> foldl' (*) 0 [1..10]
0
\end{Verbatim}
%TODO wziasc od wojtasa te drzewa na foldach
\section{Wykład \date{25-03-2025}}
\subsection{Krótki wstęp o automatach}
\subsubsection{Deterministyczne, skończone automaty}
Jak działają automaty? Automat składa się z:
\[
    \mathbb{A} = (Q,\Sigma,\delta,q_0,F), \Sigma
\]
gdzie $Q$ to zbiór stanów, $\Sigma$ to alfabet, $\delta$ to funkcja przejścia, $q_0$ to stan początkowy, a $F$ to zbiór stanów końcowych.
\[
    \delta:Q \times \Sigma \rightarrow Q
\]
\[
    q_0 \in Q, F \subseteq Q
\]
Jak wygląda to w Haskellu:
\begin{Verbatim}[frame=single]
delta :: s -> c -> s
acc :: s -> Bool

runDFA :: (s -> c -> s) -> s -> [c] -> s -- run Deterministic Finite Automat
runDFA delta start cs = foldl delta start cs
runDFA = foldl -- pożądniejsza definicja
\end{Verbatim}
Zobaczmy działanie na prostym przykładzie automatu sprawdzającego parzystość liczby binarnej:
%stwórz diagram automatu nie w kodzie tylko obrazek
\begin{center}\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
  % Stan q0: parzyste wystąpienia (akceptujący)
  \node[state, initial, accepting] (q0) {$q_0$};
  % Stan q1: nieparzyste wystąpienia
  \node[state] (q1) [right=of q0] {$q_1$};
  % Przejścia w automacie
  \path[->]
    (q0) edge [bend left] node {1} (q1)
    (q1) edge [bend left] node {1} (q0)
    (q0) edge [loop above] node {0} ()
    (q1) edge [loop above] node {0} ();
\end{tikzpicture}\end{center}
Można odpalić ten automat w następujący sposób:
\begin{Verbatim}[frame=single]
>runDFA delta q0 "10101"
False
>runDFA delta q0 "101010"
True
\end{Verbatim}

\subsubsection{Niedeterministyczne, skończone automaty}
Automat niedeterministyczny składa się z:
\[
    \mathbb{A} = (S, \delta, s_0, F)
\]
gdzie $S$ to zbiór stanów, $\delta$ to funkcja przejścia, $s_0$ to stan początkowy, a $F$ to zbiór stanów końcowych.
\[
    \delta: S \times \Sigma \rightarrow \mathcal{P}(S)
\]

\section{Wykład \date{2025-04-01}}
Dzisiaj będziemy omawiać strukturę rekordów w języku Haskell
\subsection{Struktura}
Weźmy na przykład strukturę reprezentującą osobę:
\begin{Verbatim}[frame=single]
dataOsoba = {
    idO :: Int,
    imie :: String,
    nazwisko :: String,
    rokUrodzenia :: Int,
    miesiacUrodzenia :: Int,
    dzienUrodzenia :: Int
} deriving (Show)
\end{Verbatim}
deklaracja rekordu w Haskellu wygląda następująco:
\begin{Verbatim}[frame=single]
aaa = Osoba {
    idO = 1,
    imie = "Jan",
    nazwisko = "Kowalski",
    rokUrodzenia = 2000,
    miesiacUrodzenia = 1,
    dzienUrodzenia = 1
}
\end{Verbatim}
Poprzez \textit{deriving (Show)} mówimy, że chcemy aby nasz rekord mógł być wyświetlany w konsoli. Haskel automatycznie tworzy te funkcje dla nas.
\begin{Verbatim}[frame=single]
>dzienUrodzenia aaa
1
>aaa {dzienUrodzenia = 2}
Osoba {idO = 1, imie = "Jan", nazwisko = "Kowalski", rokUrodzenia = 2000, miesiacUrodzenia = 1, dzienUrodzenia = 2}
\end{Verbatim}

Ale jest to nie elegancki sposób deklaracji rekordu, jeżeli chodzi o typ daty. Możemy zaciągnąć z jakiegoś modułu gotowy typ danych:
\begin{Verbatim}[frame=single]
import Data.Time
data Osoba = {
    idO :: Int,
    imie :: String,
    nazwisko :: String,
    dataUrodzenia :: Date
} deriving (Show)
\end{Verbatim}
Napiszmy teraz funkcję zmienająca rok urodzin, kożystając z tego co zostało napisane do tej pory
\begin{Verbatim}[frame=single]
zmienRok :: Osoba -> Int -> Osoba
zmienRok osoba nowyRok =
    osoba {dataUrodzenia = (dataUrodzenia osoba) {year = nowyRok}}
\end{Verbatim}

Poźniej w ramach tego typu problemów omówimy typ \textit{lenses}.
\subsection{Typy parametryzowalne}
Zobaczmy najpierw jak wygląda zapis pary w jezyku matematyki:
\[
    P(X) = X \times X
\]
\[
    f: \text{Int} \rightarrow \text{String}
\]
\[
    \tilde{f}: \text{Int} \times \text{Int} \rightarrow \text{String} \times \text{String}
\]
\[
    \tilde{f}(x,y) = (f(x),f(y))
\]



\subsection{Funkturo Maybe}
Myślimy o takim przekształceniu  $MB$ od słowa Mayby:
\[
    MB(X) = X \cup \{ \uparrow_X \}
\]
gdzie $\uparrow_X$ to symbol oznaczający brak wartości \textit{Nothing}, definujemy to tak:
\[
    \uparrow_X \notin X
\]
\[
    \uparrow_X \notin \text{Maybe}(X)
\]
\[
    \uparrow_X \notin \text{Maybe}(X) \setminus X
\]
\[
    X \noteq Y \implies \uparrow_X \neq \uparrow_Y
\]
Możemy wykożystać tą konstrukcje w Haskellu:
\begin{Verbatim}[frame=single]
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x
\end{Verbatim}
\begin{Verbatim}[frame=single]
safeSqrt :: Double -> Maybe Double
safeSqrt x
    | x < 0 = Nothing
    | otherwise = Just (sqrt x)
\end{Verbatim}
\begin{Verbatim}[frame=single]
safeLog :: Double -> Maybe Double
safeLog x
    | x <= 0 = Nothing
    | otherwise = Just (log x)
\end{Verbatim}
\begin{Verbatim}[frame=single]
safeDiv x 0 = Nothing
safeDiv x y = Just (x/y)
\end{Verbatim}
Teraz zaczynamy partyzanthe z \textit{Maybe}:
\begin{Verbatim}[frame=single]
composeMB :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
composeMB f g x = case f x of
    Nothing -> Nothing
    Just y -> g y
\end{Verbatim}
Zobaczmy to teraz na przykładzie
\begin{Verbatim}[frame=single]
expr1 = composeMB safeLog safeSqrt

>expr1 (exp 1)
Just 1.0
>expr1 ((expr 1)^4)
Just 2.0
>expr1 0.5
Nothing
\end{Verbatim}
Inny przykład:
\begin{Verbatim}[frame=single]
composeMB2 :: (a -> b -> Maybe c) -> Maybe a -> Maybe b -> Maybe c
composeMB2 _ Nothing _ = Nothing
composeMB2 _ _ Nothing = Nothing
composeMB2 f (Just x) (Just y) = f x y
\end{Verbatim}
I na przykładzie
\begin{Verbatim}[frame=single]
expr2 x = let sn = safeSqrt x
              ln = safeLog (x^2-4)
          in composeMB2 safeDiv sn ln
\end{Verbatim}
\begin{Verbatim}[frame=single]
>expr2 5
Just 0.7344560676556667
>expr2 2
Nothing
\end{Verbatim}
Fachowo mówi się, że zanurzamy te funkcje w konstruktor \textit{Maybe}.

\subsection{Funktor}
Zastanówmy się nad konstruktorem typów $F: \text{Set} \rightarrow \text{Set}$. Kilka przykładów takich konstruktorów:
\[
    \mathcal{P}(X) = X \times X
\]
\[
    MB(X) = X \cup \{ \uparrow_X \}
\]
\[
    L(X) = [X]
\]

Funktor: taki konstruktor typów $F$, że dla każdego $f: X \rightarrow Y$ istneje funkcja $F[f]: F(X) \rightarrow F(Y)$, która spełnia następujące warunki:
\begin{itemize}
    \item $F[\text{id}_X] = \text{id}_{F(X)}$
    \item $F[f \circ g] = F[f] \circ F[g]$
\end{itemize}
Przykłady funktorów:
\begin{itemize}
    \item
        \[
            f: X \rightarrow Y
        \]
        \[
            \tilde{\mathcal{P}}[f](x_1, x_2) = (f(x_1), f(x_2))
        \]
        jak to działa?
        \[
            \tilde{\mathcal{P}}(X) \xrightarrow{\tilde{\mathcal{P}}[f]} \tilde{\mathcal{P}}(Y)
        \]
    \item
        \[
            f: X \rightarrow Y
        \]
        \[
            MB[f]
        \]
        jak to działa?
        \[
        \]

\end{itemize}

zastąpmy \texttt{pmap} bardziej ogólnym pojęciem \textit{funktor}:
\begin{Verbatim}[frame=single]
instance Functor Para where
    fmap f (Para (x,y)) = Para (f x, f y)
\end{Verbatim}

\subsection{Big Data -- ``Hello World''}
Rozważmy problem policzenia najczęściej występujących słów w tekście. Mamy podany tekst, który interpretujemy jako \textit{String}. Napiszmy taki program i po drodzę zastanawiajmy się co bedzie potrzebne
\begin{Verbatim}[frame=single]
module HelloBDWorld where

import Data.List (words, group, sort, sortBy)
import Data.Char (toLower)
import SWEng -- StopWordsEnglish
import Control.Monad
\end{Verbatim}
należy usunąć z tekstu coś co nazywa się \textit{stop-words} np to, anything itp., oraz inne śmieci np znaki interpunkcyjne oraz w pewnym momencie jednoliterówki\\
Rownież należy zamienić wszystkie wielkie litery na małe.
\begin{Verbatim}[frame=single]
oczyscTxt :: String [String]
oczyscTxt = map (map toLower) . filter (not . flip elem stopWords) . words
\end{Verbatim}
podziel słowa na grupy i posortuj je
\begin{Verbatim}[frame=single]
grupuj :: [String] -> [(String, Int)]
grupuj = map (\xs -> (head xs, length xs)) . group . sort
\end{Verbatim}
posortuj słowa według ilości ich wystąpień
\begin{Verbatim}[frame=single]
sortuj :: [(String, Int)] -> [(String, Int)]
sortuj = sortBy (\(_,n1) (_,n2) -> compare n2 n1)
\end{Verbatim}
i na koniec podaj liste najczestrzych słow
\begin{Verbatim}[frame=single]
najczestsze :: String -> [(String, Int)]
najczestsze = sortuj . grupuj . oczyscTxt
\end{Verbatim}
\begin{Verbatim}[frame=single]
> najczestsze "Hello World! Hello Haskell!"
[("hello",2),("world",1),("haskell",1)]
\end{Verbatim}

\subsection{Jak wczytywać pliki do programu w Haskellu -- IO}


\section{Ćwiczenia}
W tym miejscu będa pojawiały się notatki z laboratorów (ćwiczeń)
\subsection{Ćwiczenia 11-03-2025}
\subsubsection{Zadanie 1}
\begin{Verbatim}[frame=single]
power :: Int => Int => Int
power x y = y ˆ x

p2 = power 4
p3 = power 3
\end{Verbatim}
\begin{enumerate}
    \item Wyznacz w GCHI wartość wyrażenia \( (p2 \circ p3)^2 \) i wyjaśnij, dlaczego otrzymałeś ten wynik.
    \item Zbadaj typy funkcji \( p2 \), \( p3 \) i \( (p2 \circ p3) \).
    \item Zapisz powyższe funkcje za pomocą wyrażeń lambda.
\end{enumerate}
\bigskip
\hrule
\bigskip
\[
    Int \rightarrow Int \rightarrow Int
\]
Zapis strzałkowy definuje nam typ funkcji operacja => jest wiążaca z prawej strony, wiec można by było to również zapisać jako:
\[
    power::Int \rightarrow (Int \rightarrow Int)
\]
\begin{enumerate}
    \item podpunkt 1
\[
    (p2 \circ p3)^2 = p2(p3(x))^2 = 4(3^x)^2 = 4 \cdot 9^x
\]
\item podpunkt 2
    \begin{Verbatim}[frame=single]
>:t p2
p2 :: Int -> Int
>:t p3
p3 :: Int -> Int
>:t (p2 . p3)
(p2 . p3) :: Int -> Int
    \end{Verbatim}
\item podpunkt 3
    \begin{Verbatim}[frame=single]
p2 = \x -> power 4 x
p3 = \x -> power 3 x
    \end{Verbatim}
\end{enumerate}
\subsubsection{Zadanie 2}
\[
2 \wedge 3 \wedge 2, \quad (2 \wedge 3) \wedge 2, \quad 2 \wedge (2 \wedge 3).
\]
Dowiedz się, jaka jest łączność oraz siła operatora \(\wedge\) za pomocą polecenia:
\[
:i (\wedge).
\]
\bigskip
\hrule
\bigskip
\begin{Verbatim}[frame=single]
>:i (^)
(^) :: (Num a, Integral b) => a -> b -> a
        -- Defined in ‘GHC.Real’
infixr 8 ^
\end{Verbatim}
Operator \(\wedge\) jest prawostronnie łączny, a jego siła wynosi 8 (najwyższa możliwa wartość, wyłącznie wyższe jest nałożenie funkcji na zmienną). W nawiasie \textbf{Num a, Integraf b} oznacza, że operator \(\wedge\) bierze jeden argument typu \textbf{Num} i drugi typu \textbf{Integral}.
\[
    2 \wedge 3 \wedge 2 = 2 \wedge (3 \wedge 2) = 2 \wedge 9 = 512
\]
\[
    (2 \wedge 3) \wedge 2 = 8 \wedge 2 = 64
\]
\[
    2 \wedge (2 \wedge 3) = 2 \wedge 8 = 256
\]

\subsubsection{Zadanie 3}
\begin{Verbatim}[frame=single]
f : : Int => Int
f x = x ˆ 2
g : : Int => Int => Int
g x y = x+2*y
h : : . . . .
h x y = f ( g x y )
\end{Verbatim}
\begin{enumerate}
    \item Jaki jest typ funkcji \( h \)? (tzn. uzupełnij \dots\ w powyższym listingu)
    \item Czy \( h = f \circ g \)?
    \item Czy \( h \, x = f(g \, x) \)?
\end{enumerate}
\bigskip
\hrule
\bigskip
\begin{enumerate}
    \item Typ funkcji \( h \) to:
        \[
            h::Int \rightarrow Int \rightarrow Int
        \]
    \item Nie, ponieważ:
        \[
            h(x,y) = f(g(x,y)) = f(x+2y) = (x+2y)^2
        \]
    \item Tak, ponieważ:
        \[
            h(x) = f(g(x)) = f(x+2x) = (x+2x)^2 = 9x^2
        \]
\end{enumerate}

\subsubsection{Zadanie 4}
Zapisz operacje binarne \( (+) \), \( (\ast) \) za pomocą lambda wyrażeń.
\bigskip
\hrule
\bigskip
\begin{Verbatim}[frame=single]
add = \x -> (\y -> x + y)
mul = \x -> (\y -> x * y)
\end{Verbatim}
Co to daje?
Mozna teraz zapisać 2+3 jako:
\begin{itemize}
    \item add 2 3
    \item (add 2) 3
    \item add 2 (3)
    \item (\$3) (2 add)
\end{itemize}

\subsubsection{Zadanie 5}
Zapisz funkcje:

\[
f(x) = 1 + x \cdot (x + 1), \quad g(x, y) = x + y^2, \quad h(y, x) = x + y^2
\]

za pomocą lambda wyrażeń w językach C++, Python, JavaScript oraz Haskell.
\bigskip
\hrule
\bigskip

W języku Haskell:
\begin{Verbatim}[frame=single]
f = \x -> 1 + x * (x + 1)
g = \x -> \y -> x + y^2
h = \y -> \x -> x + y^2
\end{Verbatim}

W języku Python:
\begin{Verbatim}[frame=single]
f = lambda x: 1 + x * (x + 1)
g = lambda x, y: x + y**2
h = lambda y, x: x + y**2
\end{Verbatim}

W języku JavaScript:
\begin{Verbatim}[frame=single]
f = x => 1 + x * (x + 1)
g = (x, y) => x + y**2
h = (y, x) => x + y**2
\end{Verbatim}

W języku C++:
\begin{Verbatim}[frame=single]
auto f = [](int x) { return 1 + x * (x + 1); };
auto g = [](int x, int y) { return x + y*y; };
auto h = [](int y, int x) { return x + y*y; };
\end{Verbatim}

\subsubsection{Zadanie 6}
Ustalmy zbiory \( A, B, C \). Niech

\[
\text{curry} : C^{B \times A} \to (C^B)^A
\]

będzie funkcją zadaną wzorem:

\[
\text{curry}(\varphi) = \lambda a \in A \to (\lambda b \in B \to \varphi(b, a)).
\]

oraz niech

\[
\text{uncurry} : (C^B)^A \to C^{B \times A}
\]

będzie zadana wzorem:

\[
\text{uncurry}(\psi)(b, a) = (\psi(a))(b).
\]

\begin{enumerate}
    \item Pokaż, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \).

    \item Wywnioskuj z tego, że \( |(C^B)^A| = |C^{B \times A}| \). Przypomnij sobie dowód tego twierdzenia, który poznałeś na pierwszym semestrze studiów.

    \item Spróbuj zdefiniować w języku Haskell odpowiedniki funkcji \texttt{curry} i \texttt{uncurry}.
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Pokażemy, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \).
        \begin{itemize}
            \item \( \text{curry} \circ \text{uncurry} \)
                \begin{equation}
                    \begin{aligned}
                        (\text{curry} \circ \text{uncurry})(\psi)
                        &= \text{curry}(\text{uncurry}(\psi)) \\
                        &= \text{curry}(\lambda a \in A \to (\lambda b \in B \to \psi(a)(b))) \\
                        &= \lambda a \in A \to (\lambda b \in B \to \psi(a)(b)).
                    \end{aligned}
                \end{equation}

            \item \( \text{uncurry} \circ \text{curry} \)
                \begin{equation}
                    \begin{aligned}
                        (\text{uncurry} \circ \text{curry})(\varphi)
                        &= \text{uncurry}(\text{curry}(\varphi)) \\
                        &= \text{uncurry}(\lambda a \in A \to (\lambda b \in B \to \varphi(b, a))) \\
                        &= \lambda b \in B \to (\lambda a \in A \to \varphi(b, a)).
                    \end{aligned}
                \end{equation}
        \end{itemize}
        Z powyższych równań wynika, że \( \text{curry} \circ \text{uncurry} = \text{id}_{(C^B)^A} \) oraz \( \text{uncurry} \circ \text{curry} = \text{id}_{C^{B \times A}} \). \qed
    \item Możemy pokazać że \texttt{curry} i \texttt{uncurry} są iniekcjami niewprost, nakładając odpowiednio przeciwne funkcje na obie strony równości:
                \begin{itemize}
            \item Załóżmy, że \( \text{curry}(\varphi_1) = \text{curry}(\varphi_2) \). Wtedy:
                \begin{equation}
                    \begin{aligned}
                        \text{curry}(\varphi_1)(a)(b) &= \text{curry}(\varphi_2)(a)(b) \\
                        \varphi_1(b, a) &= \varphi_2(b, a) \\
                        \varphi_1 &= \varphi_2.
                    \end{aligned}
                \end{equation}
            \item Załóżmy, że \( \text{uncurry}(\psi_1) = \text{uncurry}(\psi_2) \). Wtedy:
                \begin{equation}
                    \begin{aligned}
                        \text{uncurry}(\psi_1)(b, a) &= \text{uncurry}(\psi_2)(b, a) \\
                        \psi_1(a)(b) &= \psi_2(a)(b) \\
                        \psi_1 &= \psi_2.
                    \end{aligned}
                \end{equation}
        \end{itemize}
        A więc istnieje biekcja między \( (C^B)^A \) i \( C^{B \times A} \), co oznacza, że te zbiory mają taką samą moc. \qed
    \item W języku Haskell funkcje \texttt{curry} i \texttt{uncurry} można zdefiniować następująco:
        \begin{Verbatim}[frame=single]
curry :: ((b, a) -> c) -> a -> b -> c
curry f x y = f (y, x)
        \end{Verbatim}
        \begin{Verbatim}[frame=single]
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y
        \end{Verbatim}

\end{enumerate}

\subsubsection{Zadanie 7}
Podaj przykłady funkcji następujących typów:
\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow \text{Int}
\]

\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int})
\]

\[
(\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int})
\]

\bigskip
\hrule
\bigskip

\begin{itemize}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow \text{Int} \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> Int
f g = g 0
        \end{Verbatim}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> (Int -> Int)
f g x = g (g x)
        \end{Verbatim}
    \item Funkcja typu \( (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \Rightarrow (\text{Int} \Rightarrow \text{Int}) \):
        \begin{Verbatim}[frame=single]
f :: (Int -> Int) -> (Int -> Int) -> (Int -> Int)
f g h x = g (h x)
        \end{Verbatim}
\end{itemize}

\subsubsection{Zadanie 8}
Załóżmy, że chcesz oprogramować funkcję, która dla danych liczb \( a, b \) oraz funkcji \( f: \mathbb{R} \to \mathbb{R} \) oblicza
\[
\int_{a}^{b} f(x) \,dx.
\]
Jaki powinien być typ tej funkcji?

\bigskip
\hrule
\bigskip

Typ tej funkcji powinien być następujący:
\[
    \text{Num(a)} \implies a \rightarrow a \rightarrow (a \rightarrow a) \rightarrow a
\]
mogłaby ona wyglądać następująco:
\begin{Verbatim}[frame=single]
integral :: (Double -> Double) -> Double -> Double -> Double
integral f a b = undefined
\end{Verbatim}

\subsubsection{Zadanie 9 -- (Eliminacja Pętli)}
Wybierz jeden z języków Python, C++ lub JavaScript.

\begin{enumerate}
    \item Masz daną (czyli oprogramowaną) funkcję \( f: \mathbb{N} \to \mathbb{N} \). Oprogramuj funkcję, która dla danego \( n \in \mathbb{N} \) oblicza
    \[
    \sum_{k=0}^{n} f(k).
    \]
    Zrób to najpierw (standardowo) za pomocą pętli, a potem oprogramuj ją bez użycia pętli, za pomocą rekursji.

    \item Rozważamy następującą funkcję napisaną w pseudokodzie:
        \begin{Verbatim}[frame=single]
FUNCTION f(x: DOUBLE): DOUBLE
BEGIN
    DOUBLE y = sin(x);
    RETURN y*y + y + x;
ENDFNC
        \end{Verbatim}

    Oprogramuj tę funkcję w wybranym języku i następnie wyeliminuj zmienną lokalną \( y \) z tego kodu, bez pogarszania jego efektywności.
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Oto rozwiązanie w języku C++:
        \begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

// Example implementation of function f: N -> N.
// You can replace this with any function of type int -> int.
int f(int x) {
    // Example: f(x) = x + 1
    return x + 1;
}

// Function that sums using a loop:
int sumLoop(int n) {
    int sum = 0;
    for (int k = 0; k <= n; ++k) {
        sum += f(k);
    }
    return sum;
}

// Function that sums using recursion:
int sumRec(int n) {
    if(n == 0)
        return f(0);
    else
        return sumRec(n - 1) + f(n);
}

int main() {
    int n;
    cout << "Enter n: ";
    cin >> n;
    cout << "Sum computed with loop: " << sumLoop(n) << endl;
    cout << "Sum computed recursively: " << sumRec(n) << endl;
    return 0;
}
\end{lstlisting}
    funkcja \texttt{sumLoop} oblicza sumę za pomocą pętli, a funkcja \texttt{sumRec} oblicza sumę rekurencyjnie.
    \[
        \text{sumRec}(n) = \left\{
            \begin{array}{ll}
                f(0) & \text{gdy } n = 0 \\
                \text{sumRec}(n-1) + f(n) & \text{gdy } n > 0
            \end{array}
        \right.
    \]
\item Rozwiazanie w Haskellu:
    \begin{Verbatim}[frame=single]
f :: Double -> Double
f x = sin x * sin x + sin x + x
    \end{Verbatim}
    \begin{Verbatim}[frame=single]
f' :: Double -> Double
f' x = sin x * sin x + sin x + x
    \end{Verbatim}
\end{enumerate}

\subsubsection{Zadanie 10} \label{zadanie10}
Zaimplementuj samodzielnie następujące funkcje działające na listach z Prelude:
\begin{enumerate}
    \item map
    \item zip
    \item zipWith
    \item filter
    \item take
    \item drop
    \item fib
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Funkcja \texttt{map}:
        \begin{Verbatim}[frame=single]
map' :: (a -> b) -> [a] -> [b]
map' f [] = []
map' f (x:xs) = f x : map' f xs
        \end{Verbatim}
    \item Funkcja \texttt{zip}\footnote{Funkcja \texttt{zip} zwraca listę par, które są złożone z elementów listy wejściowej.
        Jeśli jedna z list jest krótsza, to wynikowa lista będzie miała długość krótszej z nich. \newline
    Przykład: \texttt{zip [1,2,3] ['a','b','c','d']} zwróci \texttt{[(1,'a'),(2,'b'),(3,'c')]}.}:
        \begin{Verbatim}[frame=single]
zip' :: [a] -> [b] -> [(a, b)]
zip' [] _ = []
zip' _ [] = []
zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
        \end{Verbatim}
    \item Funkcja \texttt{zipWith}\footnote{Funkcja \texttt{zipWith} działa podobnie jak \texttt{zip}, ale zamiast zwracać parę elementów, zwraca wynik funkcji, która jest podana jako argument. \newline
        Przykład: \texttt{zipWith (+) [1,2,3] [4,5,6]} zwróci \texttt{[5,7,9]}.}:
        \begin{Verbatim}[frame=single]
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
        \end{Verbatim}
    \item Funkcja \texttt{filter}\footnote{Funkcja \texttt{filter} zwraca listę elementów, które spełniają warunek podany jako argument. \newline
        Przykład: \texttt{filter even [1..10]} zwróci \texttt{[2,4,6,8,10]}.}:
        \begin{Verbatim}[frame=single]
filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
    | p x = x : filter' p xs
    | otherwise = filter' p xs
        \end{Verbatim}
    \item Funkcja \texttt{take}\footnote{Funkcja \texttt{take} zwraca listę składającą się z \( n \) pierwszych elementów listy wejściowej. \newline
        Przykład: \texttt{take 3 [1,2,3,4,5]} zwróci \texttt{[1,2,3]}.}:
        \begin{Verbatim}[frame=single]
take' :: Int -> [a] -> [a]
take' 0 _ = []
take' _ [] = []
take' n (x:xs) = x : take' (n - 1) xs
        \end{Verbatim}
    \item Funkcja \texttt{drop}\footnote{Funkcja \texttt{drop} zwraca listę, która jest wynikiem usunięcia \( n \) pierwszych elementów z listy wejściowej. \newline
        Przykład: \texttt{drop 3 [1,2,3,4,5]} zwróci \texttt{[4,5]}.}:
        \begin{Verbatim}[frame=single]
drop' :: Int -> [a] -> [a]
drop' 0 xs = xs
drop' _ [] = []
drop' n (_:xs) = drop' (n - 1) xs
        \end{Verbatim}
    \item Funkcja \texttt{fib}\footnote{Funkcja \texttt{fib} zwraca listę liczb Fibonacciego do \( n \)-tego elementu.}:
        \begin{Verbatim}[frame=single]
fib :: Int -> [Int]
fib n = take' n (map' fib' [0..])
    where
        fib' 0 = 0
        fib' 1 = 1
        fib' n = fib (n - 1) + fib (n - 2)
        \end{Verbatim}
\end{enumerate}
Fajne złożenie funkcji \texttt{fib} z \texttt{zipWith}:
\begin{Verbatim}[frame=single]
fib :: [Int]
fib = 0 : 1 : zipWith (+) fib (tail fib)
\end{Verbatim}
co pozwala na generowanie listy liczb Fibonacciego w nieskończoność.
Na przykład \texttt{take 10 fib} zwróci \texttt{[0,1,1,2,3,5,8,13,21,34]}.

\subsubsection{Zadanie 11}
Niech \( f = (2^{\wedge}) \) oraz \( g = (\wedge 2) \). Podaj interpretację tych funkcji.

Sprawdź wartości wyrażenia:
\[
\text{map } (\wedge 2) [1..10] \quad \text{oraz} \quad \text{map } (2^{\wedge}) [1..10]
\]
i wyjaśnij otrzymane wyniki.

\bigskip
\hrule
\bigskip

Funkcja \( f = (2 \, \wedge) \) podnosi liczbę do kwadratu, a funkcja \( g = (\wedge \, 2) \) podnosi 2 do potęgi danej liczby.
\begin{Verbatim}[frame=single]
> map (^ 2) [1..10]
[1,4,9,16,25,36,49,64,81,100]
> map (2 ^) [1..10]
[2,4,8,16,32,64,128,256,512,1024]
\end{Verbatim}

\subsubsection{Zadanie 12}
Dowiedz się, jak można przekonwertować elementy typu \texttt{Int} oraz \texttt{Integer} na typy \texttt{Float} i \texttt{Double}. Dowiedz się, jaki jest format funkcji typu \texttt{round} z \texttt{Double} do \texttt{Int}.

\bigskip
\hrule
\bigskip

\begin{itemize}
    \item Konwersja z \texttt{Int} na \texttt{Float}:
        \begin{Verbatim}[frame=single]
fromIntegral :: (Integral a, Num b) => a -> b
        \end{Verbatim}
    \item Konwersja z \texttt{Int} na \texttt{Double}:
        \begin{Verbatim}[frame=single]
fromIntegral :: (Integral a, Num b) => a -> b
        \end{Verbatim}
    \item Konwersja z \texttt{Integer} na \texttt{Float}:
        \begin{Verbatim}[frame=single]
fromInteger :: Num a => Integer -> a
        \end{Verbatim}
    \item Konwersja z \texttt{Integer} na \texttt{Double}:
        \begin{Verbatim}[frame=single]
fromInteger :: Num a => Integer -> a
        \end{Verbatim}
    \item Funkcja \texttt{round} z \texttt{Double} na \texttt{Int}:
        \begin{Verbatim}[frame=single]
round :: (RealFrac a, Integral b) => a -> b
        \end{Verbatim}
\end{itemize}

\subsection{Elementy Teorii Liczb}
Trochę teorii liczb, bo czemu nie?
\subsubsection{Zadanie 13}
Funkcję Eulera \(\varphi\) nazywamy funkcją określoną wzorem:
\begin{equation}
    \varphi(n) = \text{card}\left(\{k \leq n : \gcd(k, n) = 1\}\right),
\end{equation}
o dziedzinie \(\mathbb{N}^+\).
\begin{enumerate}
    \item Oprogramuj funkcję \(\varphi\) (funkcja \(\gcd\) jest dostępna w bibliotece \texttt{Prelude}).
    \item Napisz funkcję, która dla danej liczby naturalnej \(n\) wyznacza sumę:
        \[
            \sum_{k \mid n} \varphi(k).
        \]
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Oto implementacja funkcji \(\varphi\) w języku Haskell:
        \begin{Verbatim}[frame=single]
phi :: Int -> Int
phi n = length [k | k <- [1..n], gcd k n == 1]

> phi 10
4
        \end{Verbatim}
    \item Oto implementacja funkcji, która wyznacza sumę \(\sum_{k \mid n} \varphi(k)\):
        \begin{Verbatim}[frame=single]
sumPhi :: Int -> Int
sumPhi n = sum [phi k | k <- [1..n], n `mod` k == 0]

> sumPhi 10
10
        \end{Verbatim}
        Funkcja sumPhi jest identycznoscia na $\mathbb{N}^+$. Można zapisać to jako:
        \[
            n =N(n)= \sum_{k \mid n} \varphi(k) \cdot \underbrace{I(\frac{n}{k})}_{\equiv 1}
        \]
\end{enumerate}

\subsubsection{Zadanie 14}
Liczbę naturalną \(n\) nazywamy \textit{doskonałą}, jeżeli spełnia warunek:
\begin{equation}
    n = \sum \{ d : 1 \leq d < n \land d \mid n \}.
\end{equation}

Na przykład liczba \(6\) jest liczbą doskonałą, ponieważ:
\begin{equation}
    6 = 1 + 2 + 3.
\end{equation}

Wyznacz wszystkie liczby doskonałe mniejsze od \(10\,000\).

\textbf{Uwaga:} Do tej pory nie wiadomo, czy istnieje nieskończenie wiele liczb doskonałych.

\bigskip
\hrule
\bigskip

Oto implementacja funkcji, która znajduje wszystkie liczby doskonałe mniejsze od \(10\,000\):
\begin{Verbatim}[frame=single]
isPerfect :: Int -> Bool
isPerfect n = n == sum [d | d <- [1..n-1], n `mod` d == 0]

perfectNumbers :: [Int]
perfectNumbers = [n | n <- [1..9999], isPerfect n]

> perfectNumbers
[6,28,496,8128]
\end{Verbatim}

\subsubsection{Zadanie 15}
Parę liczb naturalnych \((m, n)\) nazywamy \textit{zaprzyjaźnionymi}, jeżeli suma dzielników właściwych każdej z nich równa się drugiej:
\[
    \sigma(m) - m = n, \quad \sigma(n) - n = m,
\]
gdzie \(\sigma(n)\) oznacza sumę wszystkich dzielników liczby \(n\).

Znajdź wszystkie zaprzyjaźnione pary, których oba składniki są mniejsze od \(10^5\).

\textbf{Uwaga:} Do tej pory nie wiadomo, czy istnieje nieskończenie wiele par liczb zaprzyjaźnionych.

\bigskip
\hrule
\bigskip

Tak może wyglądać funkcja szukająca liczb zaprzyjaźnionych w podanym zakresie:
\begin{Verbatim}[frame=single]
sumaDzielnikow :: Int -> Int
sumaDzielnikow 1 = 0
sumaDzielnikow n = 1 + sum [ if x * x == n then x
                            else if n `mod` x == 0 then x + (n `div` x)
                            else 0
                            | x <- [2..(floor . sqrt . fromIntegral) n], x * x <= n ]
    where
        limit = (floor . sqrt . fromIntegral) n

amicablePairs :: [(Int, Int)]
amicablePairs = [ (n, m)
                | n <- [2..maxVal-1]
                , let m = sumaDzielnikow n
                , m > n, m < maxVal
                , sumaDzielnikow m == n ]

> amicablePairs
[(220,284),(1184,1210),(2620,2924),(5020,5564),(6232,6368)]
\end{Verbatim}

\subsubsection{Zadanie 16}
Dla \(n \in \mathbb{N}^+\) definiujemy:
\begin{equation}
    \text{dcp}(n) = \frac{1}{2 n^2} \left| \{(k, l) \in \{1, \dots, n\} : \gcd(k, l) = 1\} \right|.
\end{equation}

\begin{enumerate}
    \item Zaimplementuj tę funkcję w języku Haskell za pomocą \textit{list comprehension}.
    \item Zoptymalizuj ten kod, pisząc rekurencyjną wersję tej funkcji.
    \item Wyznacz wartości tej funkcji dla \(n = 100, 200, 300, \dots, 10000\) i postaw jaką rozsądną hipotezę o:
        \begin{equation}
            \lim\limits_{n \to \infty} \text{dcp}(n).
        \end{equation}
\end{enumerate}

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Przykładowa implementacja przy użyciu \textit{list comprehension}:
        \begin{Verbatim}[frame=single]
dcp :: Int -> Double
dcp n = 1 / (fromIntegral (n^2))
        * fromIntegral (length [(k, l)
                                | k <- [1..n], l <- [1..n], gcd k l == 1])

> dcp 10
0.315
        \end{Verbatim}
    \item Optymalizacja kodu przy użyciu rekurencji:
        \begin{Verbatim}[frame=single]
dcp' :: Int -> Double
dcp' n = 1 / (fromIntegral (n^2)) * fromIntegral (dcp'' n 1 1)

dcp'' :: Int -> Int -> Int -> Int
dcp'' n k l
    | k > n     = 0
    | l > n     = dcp'' n (k + 1) 1
    | gcd k l == 1 = 1 + dcp'' n k (l + 1)
    | otherwise = dcp'' n k (l + 1)

> dcp' 10
0.315
        \end{Verbatim}
    \item Wyznaczenie wartości funkcji dla \(n = 100, 200, 300, \dots, 10000\):
        \begin{Verbatim}[frame=single]
dcpValues :: [Double]
dcpValues = [dcp' n | n <- [100, 200..10000]]

> dcpValues
[0.6087,0.611575,0.6088333333333333,0.60846875,0.608924,
0.6083305555555556,0.608234693877551,0.6085921875,0.6082111111111111,
0.608383,0.6084586776859504,0.6080354166666667,0.6080988165680473,
0.6082525510204081,0.6081613333333333,0.607993359375,0.6083678200692042,
0.6080601851851852,0.6080096952908588,0.60829375,0.60808231292517,
0.6079518595041322,0.6081570888468809,0.6081019097222222,0.6079608,
0.6081087278106508,0.6080426611796982,0.6079876275510203,
0.6081092746730083,0.6080416666666667,0.6080440166493236,
0.60806005859375,0.6079602387511478,0.6079895328719723,
0.6080508571428571,0.6080030092592593,0.6080139517896275,
...]
        \end{Verbatim}
        Na podstawie uzyskanych wartości można postawić hipotezę, że granica funkcji \(\text{dcp}(n)\) dla \(n \to \infty\) wynosi około $0.608 \dots$. Wartość ta może być przybliżona do wartości funkcji Eulera \(\frac{6}{\pi^2}\). \qed \\
        Można to interpretować jako gęstość liczb względnie pierwszych w zbiorze \(\{1, \dots, n\}\), ale jako iż bierzemy symetrie względem $0$ to wartość ta jest podwojona. Jednocześnie wynika to bezpośrednio z funkcji Zeta Riemanna $\zeta(2) = \frac{\pi^2}{6}$.
\end{enumerate}

\subsection{Listy -- część 1.}
Na początku tych zadań należało zastanowić się nad implementacją istniejących już funkcji z Prelude, a następnie zaimplementować je samodzielnie.
\subsubsection{Zadanie 17}
Napisz funkcję \texttt{nub}, która usunie z listy wszystkie duplikaty, np.
\[
\texttt{nub [1,1,2,2,2,1,4,1] == [1,2,4]}
\]

\bigskip
\hrule
\bigskip

Oto implementacja funkcji \texttt{nub} w języku Haskell:

\begin{Verbatim}[frame=single]
nub' :: (Eq a) => [a] -> [a]
nub' [] = []
nub' (x:xs) = x : nub' (filter (/= x) xs)
\end{Verbatim}

\subsubsection*{Jak to działa?}
\begin{enumerate}
    \item Jeśli lista pusta to zwróć pustą
        \[
            \texttt{nub' [] = []}
        \]
    \item W przeciwnym przypadku zwróć listę, której pierwszym elementem jest pierwszy element listy wejściowej (\texttt{x:xs} dzieli listę -- wyciąga pierwszy element), a resztę listy tworzy rekurencyjne wywołanie funkcji \texttt{nub'} na liście, z której usunięto wszystkie wystąpienia pierwszego elementu (\texttt{filter (/= x) xs} usuwa z xs wszystko co jest \texttt{x}).
        \[
            \texttt{nub' (x:xs) = x : nub' (filter (/= x) xs)}
        \]
\end{enumerate}

\subsubsection{Zadanie 18}
Napisz funkcję \texttt{inits}, która dla danej listy wyznaczy listę wszystkich jej odcinków
początkowych, np.
\[
    \texttt{inits [1,2,3,4] == [[],[1],[1,2],[1,2,3],[1,2,3,4]]}
\]

\bigskip
\hrule
\bigskip

Funkcja \texttt{inits} również powinna wykonywać się rekurencyjnie. Zabieramy po jednym elemencie i wpisujemy do listy.
\begin{Verbatim}[frame=single]
inits' :: [a] -> [[a]]
inits' [] = [[]]
inits' (x:xs) = [] : map (x:) (inits' xs)
\end{Verbatim}
Działa to w bardzo podobny sposób jak poprzednie:
\begin{enumerate}
    \item Jeśli lista pusta to zwróć pustą listę
        \[
            \texttt{inits' [] = [[]]}
        \]
    \item W przeciwnym przypadku narzuć mapą na wszystkie elementy listy rekurencyjne wywołanie funkcji \texttt{inits'} na liście bez pierwszego elementu, a następnie dodaj na początek każdej z tych list pierwszy element listy wejściowej
        \[
            \texttt{inits' (x:xs) = [] : map (x:) (inits' xs)}
        \]
\end{enumerate}

\subsubsection{Zadanie 19}
Napisz funkcję \texttt{tails}, która dla danej listy wyznaczy listę wszystkich jej odcinków początkowych, np.:
\[
    \texttt{tails [1,2,3,4] == [[],[4],[3,4],[2,3,4],[1,2,3,4]]}
\]

\bigskip
\hrule
\bigskip

Funkcja \texttt{tails} działa analogicznie do funkcji \texttt{inits}, ale zamiast zdejmować elementy z początku listy, zdejmuje je z końca.
\begin{Verbatim}[frame=single]
tails' :: [a] -> [[a]]
tails' [] = [[]]
tails' (x:xs) = (x:xs) : tails' xs
\end{Verbatim}
\begin{enumerate}
    \item Jeśli lista pusta to zwróć pustą listę
        \[
            \texttt{tails' [] = [[]]}
        \]
    \item W przeciwnym przypadku zwróć listę, której pierwszym elementem jest cała lista wejściowa, a resztę listy tworzy rekurencyjne wywołanie funkcji \texttt{tails'} na liście bez pierwszego elementu
        \[
            \texttt{tails' (x:xs) = (x:xs) : tails' xs}
        \]
\end{enumerate}

\subsubsection{Zadanie 20}
Napisz funkcję \texttt{splits}, która dla danej listy $xs$ wyznaczy listę wszystkich par ($ys,zs$) takich, że
\[
    \texttt{xs == ys++zs}
\]

\bigskip
\hrule
\bigskip

Funkcja \texttt{splits} powinna zwracać listę par, które są wynikiem podziału listy wejściowej na dwie części. Warto zauważyć, że dla każdego elementu listy wejściowej można zrobić podział na dwie części: jedną z elementem i drugą bez niego. W ten sposób można zrobić wszystkie możliwe podziały listy.

\begin{Verbatim}[frame=single]
splits' :: [a] -> [([a], [a])]
splits' [] = [([], [])]
splits' (x:xs) = ([], x:xs) : [(x:ys, zs) | (ys, zs) <- splits' xs]
\end{Verbatim}

\begin{enumerate}
    \item Jeśli lista pusta to zwróć listę, której jedynym elementem jest para pustych list
        \[
            \texttt{splits' [] = [([], [])]}
        \]
    \item W przeciwnym przypadku zwróć listę, której pierwszym elementem jest para pustej listy i listy wejściowej, a resztę listy tworzą pary, które są wynikiem rekurencyjnego wywołania funkcji \texttt{splits'} na liście bez pierwszego elementu
        \[
            \texttt{splits' (x:xs) = ([], x:xs) : [(x:ys, zs) | (ys, zs) <- splits' xs]}
        \]
\end{enumerate}


\subsubsection{Zadanie 21}
Oto jedna z możliwych implementacji funkcji \texttt{partition}:
\begin{Verbatim}[frame=single]
partition :: (a => Bool) => [a] => ([a], [a])
partition p xs = (filter p xs , filter (not . p) xs)
\end{Verbatim}
Ulepsz implementację tej funkcji: powinna zwracać ten sam wynik, ale powinna przchodzić przez listę tylko raz.

\bigskip
\hrule
\bigskip

Oto ulepszona implementacja funkcji \texttt{partition}: funkcja \texttt{partition'} przechodzi przez listę tylko raz, dzięki użyciu akumulatorów.

\begin{Verbatim}[frame=single]
partition' :: (a -> Bool) -> [a] -> ([a], [a])
partition' p xs = partition'' p xs [] []

partition'' :: (a -> Bool) -> [a] -> [a] -> [a] -> ([a], [a])
partition'' _ [] ys zs = (ys, zs)
partition'' p (x:xs) ys zs
    | p x = partition'' p xs (ys ++ [x]) zs
    | otherwise = partition'' p xs ys (zs ++ [x])
\end{Verbatim}

\begin{enumerate}
    \item Jeśli lista pusta to zwróć parę list \texttt{ys} i \texttt{zs}
        \[
            \texttt{partition'' \_ [] ys zs = (ys, zs)}
        \]
    \item W przeciwnym przypadku jeśli warunek \texttt{p} jest spełniony to dodaj element do listy \texttt{ys} i rekurencyjnie wywołaj funkcję \texttt{partition''} na reszcie listy, a jeśli nie to dodaj element do listy \texttt{zs} i rekurencyjnie wywołaj funkcję \texttt{partition''} na reszcie listy
        \[
            \texttt{partition'' p (x:xs) ys zs = \ldots}
        \]
\end{enumerate}
Przykładowe wywołanie:
\begin{Verbatim}[frame=single]
> partition' even [1..10]
([2,4,6,8,10],[1,3,5,7,9])
\end{Verbatim}


\subsubsection{Zadanie 22}
Zaimplementuj samodzielnie funkcje \texttt{permutations} (znajduje się ona w module \textbf{Data.List}), która dla danej listy wyznaczy listę wszystkich jej permutacji (możemy założyć, ze wszystkie elementy listy wejściowej sa różne).

\bigskip
\hrule
\bigskip

Oto implementacja funkcji \texttt{permutations} w języku Haskell:
\begin{Verbatim}[frame=single]
permutations' :: [a] -> [[a]]
permutations' [] = [[]]
permutations' (x:xs) = [ys ++ [x] ++ zs | perm <- permutations' xs,
                                          (ys, zs) <- splits' perm]
\end{Verbatim}

\begin{enumerate}
    \item Jeśli lista pusta to zwróć listę, której jedynym elementem jest pusta lista
        \[
            \texttt{permutations' [] = [[]]}
        \]
    \item W przeciwnym przypadku zwróć listę, której elementami są wszystkie możliwe permutacje listy wejściowej, które powstają przez dodanie elementu \texttt{x} na różne pozycje w permutacjach listy bez pierwszego elementu
        \begin{Verbatim}
permutations' (x:xs) = [ys ++ [x] ++ zs
            | perm <- permutations' xs, (ys, zs) <- splits' perm]
        \end{Verbatim}
\end{enumerate}



\subsubsection{Zadanie 23 -- Klasyczny Problem hetmanów}
Celem jest umieszczenie ośmiu hetmanów na szachownicy tak, aby żadne dwa hetmany nie atakowały się nawzajem, tj. nie mogą znajdować się w:
\begin{itemize}
    \item tym samym rzędzie,
    \item tej samej kolumnie,
    \item tej samej przekątnej.
\end{itemize}
\begin{enumerate}
    \item Zaimplementuj problem wyszukiwania położeń Hetmanów w Haskell’u korzystając z funkcji \texttt{permutations}.
    \item Dwa rozwiązania nazywamy równoważne jeśli pierwsze z nich można otrzymać za pomocą złożeń odbicia poziomego \textit{(reverse)} oraz odbicia pionowego (np. \texttt{map ($\lambda$ x-> n+1-x))} z drugiego. Ile jest nierównoważnych poprawnych rozstawień hetmanów?
\end{enumerate}
\textbf{Wskazówka}: Przedstaw pozycje hetmanów jako listę liczb [1, ..., n]. Przykład: ciąg [4, 2, 7, 3, 6, 8, 5, 1] oznacza, że hetman w pierwszej kolumnie jest w rzędzie 4, hetman w drugiej kolumnie jest w rzędzie 2 itd.

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item Oto implementacja problemu hetmanów w języku Haskell:
        \begin{Verbatim}[frame=single]
queens :: Int -> [[Int]]
queens n = filter check (permutations [1..n])
    where
        check xs = and [abs (xs !! i - xs !! j)
                    /= j - i | i <- [0..n-1], j <- [i+1..n-1]]
        \end{Verbatim}
    \item Aby znaleźć liczbę nierównoważnych poprawnych rozstawień hetmanów, można posłużyć się funkcją \texttt{nub} z poprzedniego zadania, która usuwa duplikaty z listy. W ten sposób można znaleźć liczbę nierównoważnych poprawnych rozstawień hetmanów.
        \begin{Verbatim}[frame=single]
unique[]=[]
unique(x:xs)=
            if reverse x `elem` xs then unique xs
            else if map (\y -> 9-y) x `elem` xs then unique xs
            else if reverse x `elem` map (\y -> 9-y) xs then unique xs
            else x:unique xs
        \end{Verbatim}
\end{enumerate}

\subsubsection{Zadanie 24}
Napisz funkcję, która oblicza iloma zerami (w układzie dziesiętnym) kończy się liczba n!. \\
\textbf{Uwaga}: taki pomysł: ``mam dane n; obliczam n!; zamieniam na łańcuch s; odwracam go; liczę ilość początkowych zer'' traktujemy jako kompletnie beznadziejny \\
\textbf{Wskazówka}: Jak można wyznaczyć największą potęgę liczby 5 która dzieli daną liczbę n?

\bigskip
\hrule
\bigskip

Implementacja funkcji, która oblicza ilość zer na końcu liczby \(n!\) w języku Haskell:
\begin{Verbatim}[frame=single]
zeros :: Int -> Int
zeros n = sum [n `div` (5^k) | k <- [1..n], 5^k <= n]
\end{Verbatim}
Działa to ponieważ liczba zer na końcu liczby \(n!\) jest równa największej potędze liczby 5, która dzieli \(n!\). Dla każdej domnożonej liczby 5 występuje przynajmniej jedna liczba 2, więc liczba zer na końcu liczby \(n!\) jest równa liczbie piątek, które dzielą \(n!\).

\subsubsection{Zadanie 25}
Ulepsz następującą ``klasyczną'' implementację funkcji quick-sort:
\begin{Verbatim}[frame=single]
qs [] = []
qs (x : xs) = qs [t | t <= xs , t<=x] ++ [x] ++ qs [t | t <= xs , t>x]
\end{Verbatim}
\textbf{Wskazówka}: Czy warto z rekursją schodzić do list jednoelementowych?

\bigskip
\hrule
\bigskip

Oto ulepszona implementacja funkcji \texttt{quickSort} w języku Haskell:
\begin{Verbatim}[frame=single]
qsort :: (Ord a) => [a] -> [a]
qsort [] = []
qsort [x]    = [x]         -- lista jednoelementowa również nie wymaga sortowania
qsort (x:xs) = qsort [y | y <- xs, y <= x]
             ++ [x] ++
             qsort [y | y <- xs, y > x]
\end{Verbatim}

\subsubsection{Zadanie 26}
Napisz funkcję \texttt{isSorted :: (Ord a) => [a] -> Bool}, która sprawdza, czy podany
argument \\$[x_1, \dots, x_n]$ jest ciągiem niemalejącym, czyli czy $x_1 \leq x_2 \leq \dots \leq x_n$.

\bigskip
\hrule
\bigskip

Implementacja funkcji \texttt{isSorted} w języku Haskell:
\begin{Verbatim}[frame=single]
isSorted :: (Ord a) => [a] -> Bool
isSorted [] = True
isSorted [_] = True
isSorted (x:y:xs) = x <= y && isSorted (y:xs)
\end{Verbatim}
Proste, iteracyjne sprawdzenie czy każdy element listy jest mniejszy lub równy następnemu.

\subsubsection{Zadanie 27}
Zaimplementuj w języku Haskell algorytm \texttt{Bubble Sort}.

\bigskip
\hrule
\bigskip

Implementacja algorytmu \texttt{Bubble Sort} w języku Haskell:
\begin{Verbatim}[frame=single]
bubbleSort :: (Ord a) => [a] -> [a]
bubbleSort xs = bubbleSort' xs (length xs)

bubbleSort' :: (Ord a) => [a] -> Int -> [a]
bubbleSort' xs 0 = xs
bubbleSort' xs n = bubbleSort' (bubble xs) (n - 1)

bubble :: (Ord a) => [a] -> [a]
bubble [x] = [x]
bubble (x:y:xs)
    | x > y     = y : bubble (x:xs)
    | otherwise = x : bubble (y:xs)
\end{Verbatim}

\subsubsection{Zadanie 28}
Typowe implementacje algorytmu \texttt{Quick Sort} sprawdzają przed wywołaniem długość listy i jeśli ma ona długość mniejszę lub równą 10, to do posortowania używają metody \texttt{Insertion Sort}. Zaimplementuj tę metodę w języku Haskell.

\bigskip
\hrule
\bigskip

Implementacja algorytmu \texttt{Insertion Sort} w języku Haskell:
\begin{Verbatim}[frame=single]
insertionSort :: (Ord a) => [a] -> [a]
insertionSort xs = foldr insert [] xs

insert :: (Ord a) => a -> [a] -> [a]
insert x [] = [x]
insert x (y:ys)
    | x <= y    = x : y : ys
    | otherwise = y : insert x ys
\end{Verbatim}

\subsubsection{Zadanie 29} \label{subsec:zad29}
Oszacuj złożoność obliczeniową następującej (kiepskiej) funkcji służącej do odwracania listy:

\begin{Verbatim}[frame=single]
rev :: [a] => [a]
rev [] = []
rev (x: xs) = (rev xs) ++ [x]
\end{Verbatim}

\bigskip
\hrule
\bigskip

Złożoność obliczeniowa funkcji \texttt{rev} jest kwadratowa, ponieważ dla każdego elementu listy wywoływana jest funkcja \texttt{rev} na reszcie listy, co daje złożoność \(O(n^2)\).

\subsubsection{Zadanie 30}
Funkcja \texttt{filter} może myć zdefiniowana za pomocą funkcji \texttt{map} i \texttt{concat}:
\begin{Verbatim}[frame=single]
filter p = concat . map box
where box x =
\end{Verbatim}
Podaj definicję tej funkcji \texttt{box}.

\bigskip
\hrule
\bigskip

Funkcja \texttt{filter} może być zdefiniowana za pomocą funkcji \texttt{map} i \texttt{concat} jeżeli nałożymy na każdy element listy warunek \texttt{p} i zwrócimy listę list, a następnie połączymy wszystkie te listy w jedną listę. Zatem \texttt{box} powinno zwracać listę, która zawiera tylko elementy spełniające warunek \texttt{p}.

\begin{Verbatim}[frame=single]
filter p = concat . map box
    where box x = if p x then [x] else []
\end{Verbatim}

\subsubsection{Zadanie 31}
Funkcje \texttt{takeWhile} i \texttt{dropWhile} są podobne do funkcji \texttt{take} i \texttt{drop}, jednakże ich pierwszym argumentem jest funkcja boolowska zamiast liczby naturalnej. Na przykład:
\begin{itemize}
    \item \texttt{takeWhile even [2,4,6,7,8,9] = [2,4,6]}
    \item \texttt{dropWhile even [2,4,6,7,8,9] = [7,8,9]}
\end{itemize}
Podaj rekurencyjne definicje tych funkcji

\bigskip
\hrule
\bigskip

Rekurencyjne definicje funkcji \texttt{takeWhile} i \texttt{dropWhile} w języku Haskell:
\begin{itemize}
    \item \texttt{takeWhile}:
        \begin{Verbatim}[frame=single]
takeWhile' :: (a -> Bool) -> [a] -> [a]
takeWhile' _ [] = []
takeWhile' p (x:xs)
    | p x       = x : takeWhile' p xs
    | otherwise = []
        \end{Verbatim}
    \item \texttt{dropWhile}:
        \begin{Verbatim}[frame=single]
dropWhile' :: (a -> Bool) -> [a] -> [a]
dropWhile' _ [] = []
dropWhile' p (x:xs)
    | p x       = dropWhile' p xs
    | otherwise = x : xs
        \end{Verbatim}
\end{itemize}

\subsubsection{Zadanie 32}
Napisz funkcję która dla ciągu łańcuchów $[L_1, \dots, L_n]$ wyznaczy ich najdłuższy wspólny prefix. \\
\textbf{Wskazówka}: Możesz skorzystać z funkcji transpose z modułu \texttt{Data.List}.

\bigskip
\hrule
\bigskip

Najdłuższy wspólny prefix listy łańcuchów można wyznaczyc poprzez transpozycję listy łańcuchów i zwrócenie wspólnego prefixu pierwszego łańcucha z resztą listy.
\begin{Verbatim}[frame=single]
longestCommonPrefix :: [String] -> String
longestCommonPrefix [] = []
longestCommonPrefix xs = takeWhile allEqual (transpose xs)

allEqual :: (Eq a) => [a] -> Bool
allEqual [] = True
allEqual [x] = True
allEqual (x:y:xs) = x == y && allEqual (y:xs)
\end{Verbatim}

\subsubsection{Zadanie 33}
Napisz funkcję \texttt{subCard :: Int -> [a] -> [[a]]}, która dla danych parametrów $k$ i $[x_1, \dots, x_n]$ wyznaczy wszystkie podciągi $[x_{i_1}, \dots, x_{i_k}]$ takie, że $1 \leq i_1 < i_2 < \dots < i_k \leq n$.

\bigskip
\hrule
\bigskip

Implementacja funkcji \texttt{subCard} w języku Haskell:
\begin{Verbatim}[frame=single]
subCard :: Int -> [a] -> [[a]]
subCard k xs = [ys | ys <- combinations k xs]

combinations :: Int -> [a] -> [[a]]
combinations 0 _ = [[]]
combinations _ [] = []
combinations k (x:xs) = map (x:) (combinations (k - 1) xs) ++ combinations k xs

> subCard 2 [1,2,3,4]
[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
\end{Verbatim}
Jak działa funkcja \texttt{combinations}? Funkcja \texttt{combinations} zwraca wszystkie kombinacje \(k\)-elementowe listy \(xs\). Jeśli \(k = 0\) to zwraca listę jednoelementową, której jedynym elementem jest pusta lista. Jeśli \(k = 0\) to zwraca pustą listę. W przeciwnym przypadku zwraca listę, której elementami są wszystkie możliwe kombinacje \(k\)-elementowe listy bez pierwszego elementu, do których dodano pierwszy element listy, oraz wszystkie kombinacje \(k\)-elementowe listy bez pierwszego elementu.

\subsection{Foldy}
\subsubsection{Zadanie 34}
Sprawdź typy i przetestuj działanie funkcji \texttt{sum}, \texttt{product}, \texttt{all} i \texttt{any}.

\bigskip
\hrule
\bigskip

Typy i działanie funkcji \texttt{sum}, \texttt{product}, \texttt{all} i \texttt{any} w języku Haskell:
\begin{Verbatim}[frame=single]
> :t sum
sum :: (Num a) => [a] -> a

> sum [1..10]
55
\end{Verbatim}
\begin{Verbatim}[frame=single]
> :t product
product :: (Num a) => [a] -> a

> product [1..10]
3628800
\end{Verbatim}
\begin{Verbatim}[frame=single]
> :t all
all :: (a -> Bool) -> [a] -> Bool

> all even [2,4,6,8,9]
False
\end{Verbatim}
\begin{Verbatim}[frame=single]
> :t any
any :: (a -> Bool) -> [a] -> Bool

> any odd [2,4,6,8,9]
True
\end{Verbatim}

\subsubsection{Zadanie 35}
Przetestuj działanie funkcji
\begin{enumerate}
    \item \texttt{foldl (+) 0 xs},
    \item \texttt{foldr (+) 0 xs},
    \item \texttt{foldl1 (+) xs},
    \item \texttt{foldr1 (+) xs} oraz
    \item \texttt{sum X} na dużych listach liczb \texttt{X}.
\end{enumerate}
\textbf{Wskazówka}: skorzystaj z polecenia \textit{GHCi} \texttt{:set +s}; w celu usunięcia wyświetlania informacji skorzystaj z polecenia \texttt{:unset +s} \\
Przetestuj następnie działanie funkcji \texttt{foldl’} oraz \texttt{foldr’} (znajdują się one w module \texttt{Data.List}).

\bigskip
\hrule
\bigskip

\begin{enumerate}
    \item \texttt{foldl (+) 0 xs}:
        \begin{Verbatim}[frame=single]
> foldl (+) 0 [1..10]
55
        \end{Verbatim}
    \item \texttt{foldr (+) 0 xs}:
        \begin{Verbatim}[frame=single]
> foldr (+) 0 [1..10]
55
        \end{Verbatim}
    \item \texttt{foldl1 (+) xs}:
        \begin{Verbatim}[frame=single]
> foldl1 (+) [1..10]
55
        \end{Verbatim}
    \item \texttt{foldr1 (+) xs}:
        \begin{Verbatim}[frame=single]
> foldr1 (+) [1..10]
55
        \end{Verbatim}
    \item \texttt{sum X} na dużych listach liczb \texttt{X}:
        \begin{Verbatim}[frame=single]
> :set +s
> sum [1..1000000]
500000500000
(0.03 secs, 88,077,128 bytes)
        \end{Verbatim}
    \item \texttt{foldl'} oraz \texttt{foldr'}:
        \begin{Verbatim}[frame=single]
> :module Data.List
> :set +s
> foldl' (+) 0 [1..1000000]
500000500000
(0.03 secs, 88,077,144 bytes)
> foldr' (+) 0 [1..1000000]
500000500000
        \end{Verbatim}
\end{enumerate}

\subsubsection{Zadanie 36}
Samodzielnie zaimplementuj (oraz przetestuj) funkcję \texttt{reverse} działającą w czasie liniowym. Porównaj jej skuteczność z algorytmem z Zadania 29 \ref{subsec:zad29}.

\bigskip
\hrule
\bigskip

Implementacja funkcji \texttt{reverse} działającej w czasie liniowym w języku Haskell:
\begin{Verbatim}[frame=single]
reverse' :: [a] -> [a]
reverse' = foldl (flip (:)) []
\end{Verbatim}

\subsubsection{Zadanie 37}
Zdefiniuj za pomocą funkcji \texttt{foldr} funkcję, które dla listy liczb $[a_1, \dots, a_n]$ oblicza ile liczb parzystych występuje w tej liście.

\bigskip
\hrule
\bigskip

To tak może wyglądać:
\begin{Verbatim}[frame=single]
countEven :: [Int] -> Int
countEven = foldr (\x acc -> if even x then acc + 1 else acc) 0
countEven = foldr ((+) . (\x -> if even x then 1 else 0)) 0
\end{Verbatim}

\subsubsection{Zadanie 38}
Korzystając z funkcji \texttt{foldl} napisz funkcję \texttt{dec2Int} która konwertuje ciąg cyfr na liczbę całkowita, np. \texttt{dec2Int [1,2,1] = 121}.

\bigskip
\hrule
\bigskip

Implementacja funkcji \texttt{dec2Int} w języku Haskell:
\begin{Verbatim}[frame=single]
dec2Int :: [Int] -> Int
dec2Int xs = foldl (\acc x -> acc * 10 + x) 0 xs

> dec2Int [1,2,1]
121
\end{Verbatim}
Alternetywnie można coś ciekawego napisać przy pomocy funkcji \texttt{afib}
\begin{Verbatim}[frame=single]
afib = 1:zipWith (-) 0:afib
...
\end{Verbatim}

\subsubsection{Zadanie 39}
Która z następujących równości jest prawdziwa?
\begin{enumerate}
    \item \texttt{foldl (-) e xs = e - sum xs}
    \item \texttt{foldr (-) e xs = e - sum xs}
\end{enumerate}

\bigskip
\hrule
\bigskip

Prawdziwa jest równość:
\begin{enumerate}
    \item \texttt{foldl (-) e xs = e - sum xs}
\end{enumerate}
Ponieważ \texttt{foldl (-) e xs} to \texttt{e - x1 - x2 - ... - xn}, a \texttt{sum xs} to \texttt{x1 + x2 + ... + xn}.

\subsubsection{Zadanie 40}
Dla danej listy \texttt{$x_s = [x_1, \ldots, x_n]$} funkcja \texttt{lmss xs} wyznacza najdłuższą listę \texttt{$[x_{j_1}, \ldots, x_{j_k}]$} taką, że \texttt{$j_1 = 1$} oraz \texttt{$x_{j_a} < x_{j_{a+1}}$} dla wszystkich \texttt{$a = 1, \ldots, k - 1$}.\\
Na przykład, dla ciągu \texttt{xs = [3,2,1,5,3,2,6,2,3,8]} mamy \texttt{lmss xs = [3,5,6,8]}.

\bigskip
\hrule
\bigskip
\texttt{lmss} to skrót od \textit{longest monotonically increasing subsequence}. Oto implementacja funkcji \texttt{lmss} w języku Haskell:
\begin{Verbatim}[frame=single]
addWhenSmaller xs n = xs ++ map (++[n]) (filter (\x -> if (x==[])
    then True else last x < n) xs)

longest [x] = x
longest (x:xs) =
    if (length x > length l) then x
    else l
    where l = longest xs
\end{Verbatim}

\subsubsection{Zadanie 41}
Funkcja \texttt{remdupl} usuwa z listy przylegające duplikaty, np. \\ \texttt{remdupl [1,1,2,1,1,3,3,4,4] = [1,2,1,3,4]}. Oprogramuj tę funkcję za pomocą \texttt{foldr} lub \texttt{foldl}.

\bigskip
\hrule
\bigskip

\begin{Verbatim}[frame=single]
remdupl :: (Eq a) => [a] -> [a]
remdupl = foldr (\x acc -> if null acc
    || x /= head acc then x:acc else acc) []
\end{Verbatim}

\subsubsection{Zadanie 42}
Korzystając z funkcji \texttt{foldl} i \texttt{foldr} napisz funkcję \texttt{approx n} zdefiniowaną następująco
\[
\texttt{approx}(n) = \sum_{k=1}^{n} \frac{1}{k!}
\]

\bigskip
\hrule
\bigskip

Implementacja funkcji \texttt{approx} w języku Haskell:
\begin{Verbatim}[frame=single]
approx :: Int -> Double
approx n = foldl (\acc k -> acc + 1 / fromIntegral (product [1..k])) 0 [1..n]

ghci> approx 100
1.7182818284590455
(0.01 secs, 774,656 bytes)
ghci> approx 1000
1.7182818284590455
(0.08 secs, 211,092,144 bytes)
ghci> approx 10000
1.7182818284590455
(34.83 secs, 227,568,464,200 bytes)
\end{Verbatim}

\subsubsection{Zadanie 43}
Napisz, korzystając z funkcji \texttt{foldl}, funkcję która dla ciągu liczb $[a_1,\dots, a_n]$
\[
    \sum^n_{k=1} (-1)^{k+1} \cdot a_k
\]

\bigskip
\hrule
\bigskip

\begin{Verbatim}[frame=single]
altSum :: (Num a) => [a] -> a
altSum xs = foldl (\acc (k, x) -> acc + (-1)^(k+1) * x) 0 (zip [1..] xs)
\end{Verbatim}

\subsubsection{Zadanie 44}
Napisz funkcję która dla zadanej listy $[a_1,\dots, a_n]$ elementu typu \texttt{[Fractional a]} wyznaczy średnią arytmetyczną oraz wariancję ciągu $(a_1, \dots , a_n)$. Skorzystaj tylko raz z funkcji fold.

\bigskip
\hrule
\bigskip

\begin{Verbatim}[frame=single]
meanVar :: (Fractional a) => [a] -> (a, a)
meanVar xs = (mean, var)
    where
        (mean, var, n) = foldl (\(m, v, n) x -> (m + x, v + x^2, n + 1)) (0, 0, 0) xs
        mean = mean / fromIntegral n
        var = (var - mean^2 * fromIntegral n) / fromIntegral (n - 1)
\end{Verbatim}

\subsubsection{Zadanie 45}
Zaimplementuj deterministyczny automat skończony który rozpoznaje język tych zero-jedynkowych ciągów która zaczynają się od \texttt{01} i zawierają parzystą liczbę jedynek.

\bigskip
\hrule
\bigskip

Rozrysujmy najpierw ten automat:
\begin{center}\begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, on grid, auto]
    % Definicja stanów
    \node[state, initial] (q0) {$q_0$};
    \node[state] (q1) [right=of q0] {$q_1$};
    \node[state] (q2) [right=of q1] {$q_2$};
    \node[state, accepting] (q3) [right=of q2] {$q_3$};
    \node[state] (sink) [below=of q1] {$\mathsf{sink}$};

    % Przejścia między stanami
    \path[->]
        (q0) edge node {0} (q1)
        (q0) edge node {1} (sink)
        (q1) edge node {1} (q2)
        (q1) edge node {0} (sink)
        (q2) edge[bend left] node {1} (q3)
        (q2) edge[loop above] node {0} ()
        (q3) edge[bend left] node {1} (q2)
        (q3) edge[loop above] node {0} ()
        (sink) edge[loop below] node {0,1} ();
\end{tikzpicture}\end{center}
gdzie stan \texttt{sink} jest stanem z którego nie ma wyjścia, a stan \texttt{q3} jest stanem akceptującym.
\begin{Verbatim}[frame=single]
dfa :: String -> Bool
dfa xs = (foldl f 0 xs) == 3

f :: Int -> Int -> Int
f _ _ = -1
f 0 0 = 1
f 0 1 = -1
f 1 0 = -1
f 1 1 = 2
f 2 0 = 2
f 2 1 = 3
f 3 0 = 3
f 3 1 = 2
\end{Verbatim}
I es
\end{document}
