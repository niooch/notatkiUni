\documentclass[11pt,a4paper]{article}

% Kodowanie i obsługa języka polskiego
\usepackage[utf8]{inputenc}      % Kodowanie wejścia
\usepackage[T1]{fontenc}         % Kodowanie fontów
\usepackage[polish]{babel}       % Obsługa języka polskiego

% Pakiety matematyczne i inne przydatne
\usepackage{marginnote}
\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage{amsmath, amssymb, amsthm}  % Pakiety do matematyki
\usepackage{graphicx}                  % Obsługa grafiki
\usepackage{hyperref}                  % Linki i spis treści
\usepackage{geometry}                  % Ustawienie marginesów
\usepackage{algorithm}               % Algorytmy
\usepackage{algpseudocode}           % Pseudokod
\geometry{margin=2cm}                  % Ustawienie marginesów na 2 cm

% Dodatkowe ustawienia
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
\title{Notatki z Algorytmów i Struktur Danych}
\author{Jakub Kogut}

\begin{document}

\maketitle

\tableofcontents  % Spis treści (opcjonalnie)
\newpage

\section{Wstęp}
To będa notatki z przedmiotu Algorytmy i struktury danych na Politechnice Wrocławskiej na kierunku Informatyka Algorytmiczna rok 2025 semestr letni.
\subsection{Informacje}
Prowadzący Przedmiot: \textbf{Zbychu Gołębiewski}
\begin{itemize}
    \item Należy kontaktować się przez maila: \href{mailto:zbigniew.golebiewski@pwr.edu.pl}{mail}
    \item Konsultacje \textbf{216/D1}:
        \begin{itemize}
            \item Wtorek 13:00-15:00
            \item Środa 9:00-11:00
        \end{itemize}
    \item Wiecej info na stronie \href{https://cs.pwr.edu.pl/golebiewski/teaching/aisd.php}{przedmiotu}
    \item Literatura
        \begin{itemize}
            \item Algorithms, Dasgupta, Papadimitriou, Vazirani
            \item Algorithms, Sedgewick, Wayne (strona internetowa książki)
            \item Algorithms Designs, Jon Kleinberg and Eva Trados
            \item Wprowadzenie do algorytmów, Cormen, Leiserson, Rivest, Stein
            \item Sztuka programowania (wszystkie tomy), Donald E. Knuth
        \end{itemize}
\end{itemize}
\subsection{Ocenianie}
Ocena z kursu składa się z:
\begin{itemize}
    \item Oceny z egzaminu -- E
    \item Oceny z ćwiczeń -- C
    \item Oceny z laboratorium -- L
\end{itemize}
Wszystkie oceny są z zakresu $[0,100]$. Ocena końcowa jest wyliczana ze wzoru:
\[
    K = \frac{1}{2}E + \frac{1}{4}C + \frac{1}{4}L
\]

\section{Wykład \date{2025-03-03}}
\subsection{Przykładowy Problem}
Sortowanie:
\begin{itemize}
    \item Input: $n$ liczb $a_1, a_2, \ldots, a_n, |A|$, gdzie $|A|$ to długośc tablicy
    \item Output: permutacja $a_1', a_2', \ldots, a_n'$ taka, że $a_1' \leq a_2' \leq \ldots \leq a_n'$
\end{itemize}
Najważniejsze w algorytmach jest to, żeby były POPRAWNE: edge case, ...

\subsection{Jak mierzyć złożoność algorytmów}
\begin{enumerate}
    \item Worst Case Analysis T(n) $\leftarrow$ stosowane najcześciej
    \item Average Case Analysis
        \begin{itemize}
            \item zakładamy pewnien rozkład prawdopodobieństwa na danych wejściowych
            \item $T$ -- zmienna losowa liczby operacji wykonanych przez algorytm
                \[
                    T(n) = \max\{\# \text{operacji dla danego wejścia}\}
                \]
            \item $E[T]$ -- wartość oczekiwana $T$ $\rightarrow$ średnia liczba operacji, to co nas interesuje
        \end{itemize}
\end{enumerate}
\subsection{Przykład algorytmu}
W tej sekcji mamy pokazany przykład jak pisać pseudo kod:
\begin{algorithm}[H]
    \caption{Merge Sort}\label{alg:merge_sort}
    \begin{algorithmic}[1]
    \Procedure{MergeSort}{A, 1, n}
        \If{|A[1..n]| == 1}
            \State \Return{A[1..n]}
        \Else
            \State $B = \text{MergeSort}(A, 1, \lfloor n/2 \rfloor)$
            \State $C = \text{MergeSort}(A, \lfloor n/2 \rfloor, n)$
            \State \Return{Merge(B, C)}
        \EndIf
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
    \caption{Merge}\label{alg:merge}
    \begin{algorithmic}[1]
    \Procedure{Merge}{X[1..k], Y[1..n]}
        \If{$X = \emptyset$}
            \State \Return{$Y$}
        \ElsIf{$Y = \emptyset$}
            \State \Return{$X$}
        \ElsIf{$X[1] \leq Y[1]$}
            \State \Return{$[X[1]] \times \text{Merge}(X[2..k], Y[1..n])$}
        \Else
            \State \Return{$[Y[1]] \times \text{Merge}(X[1..k], Y[2..n])$}
        \EndIf
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
\subsection{Przykład działania Merge Sort}
\textbf{Example: Sorting the array \([10,\, 2,\, 5,\, 3,\, 7,\, 13,\, 1,\, 6]\) step by step}

\begin{enumerate}
  \item \textbf{Initial split:}
  \[
    [\,10,\, 2,\, 5,\, 3,\, 7,\, 13,\, 1,\, 6\,]
    \quad\longrightarrow\quad
    [\,10,\, 2,\, 5,\, 3\,] \quad\text{and}\quad [\,7,\, 13,\, 1,\, 6\,].
  \]

  \item \textbf{Sort the left half \([10,\, 2,\, 5,\, 3]\):}
  \begin{enumerate}
    \item Split into \([10,\, 2]\) and \([5,\, 3]\).
    \item \(\text{MergeSort}([10,\, 2])\):
    \begin{itemize}
      \item Split into \([10]\) and \([2]\).
      \item Each is already sorted (single element).
      \item Merge: \([2,\, 10]\).
    \end{itemize}
    \item \(\text{MergeSort}([5,\, 3])\):
    \begin{itemize}
      \item Split into \([5]\) and \([3]\).
      \item Each is already sorted.
      \item Merge: \([3,\, 5]\).
    \end{itemize}
    \item Merge \([2,\, 10]\) and \([3,\, 5]\) to get \([2,\, 3,\, 5,\, 10]\).
  \end{enumerate}

  \item \textbf{Sort the right half \([7,\, 13,\, 1,\, 6]\):}
  \begin{enumerate}
    \item Split into \([7,\, 13]\) and \([1,\, 6]\).
    \item \(\text{MergeSort}([7,\, 13])\):
    \begin{itemize}
      \item Split into \([7]\) and \([13]\).
      \item Each is already sorted.
      \item Merge: \([7,\, 13]\).
    \end{itemize}
    \item \(\text{MergeSort}([1,\, 6])\):
    \begin{itemize}
      \item Split into \([1]\) and \([6]\).
      \item Each is already sorted.
      \item Merge: \([1,\, 6]\).
    \end{itemize}
    \item Merge \([7,\, 13]\) and \([1,\, 6]\) to get \([1,\, 6,\, 7,\, 13]\).
  \end{enumerate}

  \item \textbf{Final merge:} Merge the two sorted halves:
  \[
    [\,2,\, 3,\, 5,\, 10\,] \quad\text{and}\quad [\,1,\, 6,\, 7,\, 13\,]
    \quad\longrightarrow\quad [\,1,\, 2,\, 3,\, 5,\, 6,\, 7,\, 10,\, 13\,].
  \]
\end{enumerate}

\noindent
Hence, after all the recursive splits and merges, the final sorted array is:
\[
[\,1,\, 2,\, 3,\, 5,\, 6,\, 7,\, 10,\, 13\,].
\]

\subsection{Złożoność Merge Sort}
\begin{itemize}
    \item Złożoność czasowa
        \begin{itemize}
            \item $T(n) = 2T(n/2) + \Theta(n)$
            \item $T(n) = \Theta(n \log n)$
        \end{itemize}
    \item Złożoność pamięciowa
        \begin{itemize}
            \item $M(n) = n + M(n/2)$
            \item $M(n) = \Theta(n)$
        \end{itemize}
\end{itemize}

\section{Wykład \date{2025-03-10}}
\subsection{Notacja Asypmtotyczna}
Na wykładzie będziemy omawiali:
\begin{itemize}
    \item Notację dużego O $O(n)$ //ograniczenie górne
        \begin{itemize}
                \item Definicja $O(n)$:
                \[
                    O(g(n)) = \{ f(n) \mid \exists c > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq f(n) \leq c \cdot g(n) \}
                \]
            \item Uwaga! \newline
                Jeśli
                \[
                    \limsup_{n \to \infty} \frac{f(n)}{g(n)} < \infty
                \]
                to
                \[
                    \limsup_{n \to \infty} \frac{f(n)}{g(n)} = \lim_{n \to \infty} \frac{f(n)}{g(n)}
                \]
            \item Przykład:
                \begin{itemize}
                    \item $2n^2=O(n^3)$
                        dla $n_0 = 2, c = 1$ Definicja jest spełniona
                    \item $f(n) = n^3 + O(n^2)$ jest to jeden z sposobów użycia $O(n)$
                        \[
                            \exists h(n) = O(n^2) \quad \text{takie, że} \quad f(n) = n^3 + h(n)
                        \]
                \end{itemize}
        \end{itemize}
    \item Notację omega //ograniczenie dolne
        \begin{itemize}
            \item Definicja
                \[
                    \Omega(g(n)) = \{ f(n) \mid \exists c > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq c \cdot g(n) \leq f(n) \}
                \]
            \item Przykład
                \begin{itemize}
                    \item $n^3 = \Omega(2n^2)$
                    \item $n = \Omega(\log n)$
                \end{itemize}
        \end{itemize}
    \item Notację theta $\theta(n)$ //ograniczenie z dwóch stron
        \begin{itemize}
            \item Definicja
                \[
                    \Theta(g(n)) = \{ f(n) \mid \exists c_1, c_2 > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \}
                \]
            \item Przykład
                \begin{itemize}
                    \item $n^3 = \Theta(n^3)$
                    \item $n^3 = \Theta(n^3 + 2n^2)$
                    \item $log n +8 + \frac{1}{12n} = \Theta(\log n)$
                \end{itemize}
            \item Uwaga!
                \[
                    f(n) = \Theta(g(n)) \iff f(n) = O(g(n)) \land f(n) = \Omega(g(n))
                \]
                Można to zapisać jako klasy funkcji:
                \[
                    \Theta(g(n)) = O(g(n)) \cap \Omega(g(n))
                \]
        \end{itemize}
    \item Patologiczny przykład:
        mamy funkcje $g(n) = n$ oraz $f(n) = n^{1+sin{\frac{\pi n}{2}}}$, a więc
        \[
            f(n) = \begin{cases}
                n^2 & \text{dla n parzystych} \\
                n & \text{dla n nieparzystych}
            \end{cases}
        \]
        wtedy
        \[
            \limsup_{n \to \infty} \frac{f(n)}{g(n)} = \infty
        \]
        \[
            \limsup_{n \to \infty} \frac{g(n)}{f(n)} = \infty
        \]
        zatem
        $f \neq O(g)$ oraz $g \neq O(f)$
    \item o małe
        \begin{itemize}
            \item Definicja
                \[
                    o(g(n)) = \{ f(n) \mid \forall c > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq f(n) < c \cdot g(n) \}
                \]
                Równoważnie
                \[
                    lim_{n \to \infty} \frac{f(n)}{g(n)} = 0
                \]
            \item Przykład
                \begin{itemize}
                    \item $n^2 = o(n^3)$ i $n^2 O(n^3)$ ale $n^2 \neq o(n^2)$
                    \item $n = o(n^2)$
                \end{itemize}
        \end{itemize}
\end{itemize}

\subsection{Rekurencja}
\begin{itemize}
    \item Metoda podstawienia (metoda dowodu indukcyjnego)
        \begin{enumerate}
        \item Zadnij Odpowiedź (bez stałych)
        \item Sprawdź przez indukcję czy odpowiedź jest poprawna
        \item Wylicz stałe
        \end{enumerate}
        \begin{itemize}
            \item Przykład
                \begin{itemize}
                    \item $T(n) = T(\frac{n}{2}) + n$
                    \item Pierwotny strzał: $T(n) = O(n^3)$
                    \item cel: Pokazać, że $\exists c>0: T(n) \leq c \cdot n^3$
                        \begin{itemize}
                            \item warunek początowy: $T(1) = 1 \leq c$
                            \item krok indukcyjny: załóżmy, że $\forall k \leq n: T(k) \leq ck^3$
                        \end{itemize}
                        \[
                            T(n) = 4T(\frac{n}{2}) + n \leq 4c(\frac{n}{2})^3 + n = \frac{1}{2}cn^3 + n \leq cn^3 \quad \text{dla} \quad c \geq 2
                        \]
                        jednakże ``Przestrzeliliśmy'' znacznie, spróbojmy wzmocnić założenie indukcyjne:
                        \[
                            T(n) \leq c_1k^2 -c_2k, k < n
                        \]
                        wtedy mamy:
                        \[
                            T(n) = 4T(\frac{n}{2}) +n \leq 4(c_1(\frac{n}{2})^2 - c_2(\frac{n}{2})) + n = c_1n^2 - 2c_2n + n \leq c_1n^2 - c_2n
                        \]
                        zatem $c_1 = 1, c_2 = 1$ i $T(n) = O(n^2)$ \qed
                \end{itemize}
            \item Przykład
                \begin{itemize}
                    \item $T(n) = 2T(\sqrt{n}) + \log n$
                        \newline
                        załóżmy, że $n$ jest potęgą liczby $2$, czyli $n = 2^m$
                        \[
                            T(2^m) = 2T(2^{\frac{m}{2}}) + m
                        \]
                        Co implikuje
                        \[
                            T(2^\frac{m}{2}) \rightarrow S(m)
                        \]
                        wtedy
                        \[
                            S(m) = 2S(\frac{m}{2}) + m
                        \]
                        rozwiązując rekurencję otrzymujemy
                        \[
                            S(m) = m \log m
                        \]
                        zatem
                        \[
                            T(n) = \log n \log \log n
                        \]
                \end{itemize}
        \end{itemize}

\end{itemize}
\section{Wykład \date{2025-03-17}}
\subsection{Dzrzewo rekursji}
Przykład dzewa rekursji:
\begin{itemize}
    \item $T(n) = T(\frac{n}{2})+T(\frac{n}{4}) + n^2$
\end{itemize}
\begin{center}
\begin{tikzpicture}
    [level distance=1.5cm,
    level 1/.style={sibling distance=4cm},
    level 2/.style={sibling distance=2cm}]
    \node {$n^2$}
        child {node {$\frac{n^2}{4}$}
            child {node {$\frac{n^2}{16}$}}
            child {node {$\frac{n^2}{64}$}}
        }
        child {node {$\frac{n^2}{16}$}
            child {node {$\frac{n^2}{64}$}}
            child {node {$\frac{n^2}{256}$}}
        };
      \node[draw=none] at (-4.5,0) {$n^2$};
      \node[draw=none] at (-4.5,-1.5) {$\frac{5}{16}n^2$};
      \node[draw=none] at (-4.5,-3) {$\frac{25}{256}n^2$};
\end{tikzpicture}
\end{center}
\subsubsection*{Uwaga!}
Nie jest to formalne rozwiązanie problemu. Nie można używać drzewa rekursji do dowodzenia złożoności algorytmów. Jest to jedynie intuicyjne podejście do problemu. Trzeba policzyć to na piechote, aby było formalnie.\newline
Aby policzyć $T(n)$ musimy policzyć sumę wszystkich wierzchołków w drzewie rekursji.
\[
    T(n) = \sum^{\infty}_{k=0} \left(\frac{5}{16}\right)^k \cdot n^2 = n^2 \sum^{\infty}_{k=0} \left(\frac{5}{16}\right)^k = n^2 \frac{1}{1-\frac{5}{16}} = n^2 \frac{16}{11} = \frac{16}{11}n^2
\]
A wiec $T(n) = O(n^2)$
\newline
Możemy to policzyć dokładniej dostajac mniejsze wyrazy w sumie.
%TODO przepisac od szymiego

\subsecton{Metoda iteracyjna}
Weźmy na przykład taką rekurencję:
\[
    T(n) = 3T(\frac{n}{4}) + n
\]
Zobaczmy co się dzieje po podstawieniu rekurencji do samej siebie:
\begin{enumerate}
    \item $T(n) = 3T(\frac{n}{4}) + n$
    \item $T(n) = 3(3T(\frac{n}{16}) + \frac{n}{4}) + n = 3^2T(\frac{n}{16}) + \frac{3}{4}n + n$
    \item $T(n) = 3^2(3T(\frac{n}{64}) + \frac{n}{16}) + \frac{3}{4}n + n = 3^3T(\frac{n}{64}) + \frac{3}{16}n + \frac{3}{4}n + n$
    \item \dots \footnote{Warto zauważyć, że jest to analogicznie do liczenia sumy wszystkich nodów drzewa rekursji}
\end{enumerate}
A więc ogólnie wychodzi:
\[
    %T(n) = \sum^{\log_{2}n}_{k=0} \frac{{3}{4}
\]
\subsection{Master Theorem}
Niech $a \geq 1, b > 1, f(n), d \in \mathbb{N}$ oraz $f(n)$ będzie funkcją nieujemną. Rozważmy rekurencję:
\[
    T(n) = aT(\frac{n}{b}) + \Theta(n^d)
\]
gdzie $a$ i $b$ są stałymi, a $f(n)$ jest funkcją nieujemną. Wtedy:
\begin{enumerate}
    \item $\Theta(n^d)$ jeśli $d > \log_b a$
    \item $\Theta(n^d \log n)$ jeśli $d = \log_b a$
    \item $\Theta(n^{\log_b a})$ jeśli $d < \log_b a$
\end{enumerate}
\subsubsection*{Szkic D-d}
Do przedstawienia problemu użyjemy drzewa rekursji. Rozważmy rekurencję:
\[
    T(n) = aT(\frac{n}{b}) + \Theta(n^d)
\]
\begin{center}
\begin{tikzpicture}
    [level distance=1.5cm,
    level 1/.style={sibling distance=4cm},
    level 2/.style={sibling distance=2cm}]
    \node {$c \cdot n^d$}
        child {node {$c \cdot \left(\frac{n}{b}\right)^d$}
            child {node {$c \cdot \left(\frac{n}{b^2}\right)^d$}}
            child {node {$c \cdot \left(\frac{n}{b^2}\right)^d$}}
        }
        child {node {$c \cdot \left(\frac{n}{b}\right)^d$}
            child {node {$c \cdot \left(\frac{n}{b^2}\right)^d$}}
            child {node {$c \cdot \left(\frac{n}{b^2}\right)^d$}}
        };
      \node[draw=none] at (-4.5,0) {$n^d$};
      \node[draw=none] at (-4.5,-1.5) {$\frac{n^d}{b^d}$};
      \node[draw=none] at (-4.5,-3) {$\frac{n^d}{b^{2d}}$};
  \end{tikzpicture} %TODO zrobic lepsze drzewo...
\end{center}
\begin{enumerate}
    \item suma kosztoów w $k$--tym kroku
        \[
            a^k c (\frac{n}{b^k})^d = c (\frac{a}{b^d})^k n^d
        \]
        gdzie $c(\frac{n}{b^k})^d$ to koszt jednego podproblemu w $k$--tym kroku
    \item obliczenie wysokości drzewa:
        \[
            \frac{n}{b^h} = 1 \rightarrow h = \log_b n
        \]
    \item Obliczenie $T(n)$
        \begin{equation*}
            T(n) = \Theta(\sum^{\log_b n}_{k=0} c\frac{a}{b^k}n^d) \\
                 &= \Theta(c \cdot n^d \sum^{\log_b n}_{k=0} (\frac{a}{b^d})^k) \\
                 &= \Theta(c \cdot n^d \frac{1-(\frac{a}{b^d})^{\log_b n + 1}}{1-\frac{a}{b^d}}) \implies T(n) = \Theta(n^d)
        \end{equation*}
    \item rozważmy 3 przypadki:
        \begin{enumerate}
            \item $d > \log_b a$ \marginpar{root -- heavy}
                \[
                    T(n) = \Theta(n^d)
                \]
            \item $d = \log_b a$ \marginpar{równo}
                \[
                    T(n) = \Theta(n^d \log n)
                \]
            \item $d < \log_b a$ \marginpar{leaf -- heavy}
                \[
                    T(n) = \Theta(n^{\log_b a})
                \]
        \end{enumerate}
\end{enumerate}

\subsubsection*{Przykłady}
\begin{itemize}
    \item $T(n) = 4T(\frac{n}{2}) + 11n$ \newline
        Wtedy kożystając z \textbf{Master Theorem} mamy:
        \[
            a = 4, b = 2, d = 1
        \]
        Jak i również
        \[
            \log_b a = \log_2 4 = 2 > 1 = d \implies T(n) = \Theta(n^2)7
        \]
    \item $T(n) = 4T(\frac{n}{3}) + 3n^2$ \newline
        Wtedy
        \[
            a = 4, b = 3, d = 2
        \]
        Jak i również
        \[
            \log_b a = \log_3 4 > 2 = d \implies T(n) = \Theta(n^{\log_3 4})
        \]
    \item $T(n) = 27T(\frac{n}{3}) + \frac{n^2}{3}$ \newline
        Wtedy
        \[
            a = 27, b = 3, d = 2
        \]
        Jak i również
        \[
            \log_b a = \log_3 27 = 3 > 2 = d \implies T(n) = \Theta(n^3\log n)
        \]
\end{itemize}

\subsection{Metoda dziel i zwyciężaj (D\&C)}
Na czym ona polega?
\begin{enumerate}
    \item Podział problemu na mniejsze podproblemy \footnote{W zapisie rekurencyjnym $T(n) = cT(cn) + \underline{n^d}$}
    \item Rozwiazanie rekurencyjnie mniejsze podpoblemy
    \item połącz rozwiązania podproblemów w celu rozwiązania problemu wejściowego
\end{enumerate}
\subsubsection*{Algorytm -- Binary Search}
\begin{itemize}
    \item \textbf{Input}: posortowania tablica \texttt{A[1..n]} oraz element \texttt{x}
    \item \textbf{Output}: indeks \texttt{i} taki, że \texttt{A[i] = x} lub \texttt{0} jeśli \texttt{x} nie występuje w \texttt{A}
        \item przebieg algorytmu: %pseudokod
            \begin{algorithm}[H]
                \caption{Binary Search}
                \begin{algorithmic}[1]
                    \Procedure{BinarySearch}{A, x}
                        \State $l = 1$
                        \State $r = |A|$
                        \While{$l \leq r$}
                            \State $m = \lfloor \frac{l+r}{2} \rfloor$
                            \If{$A[m] = x$}
                                \State \Return{$m$}
                            \ElsIf{$A[m] < x$}
                                \State $l = m + 1$
                            \Else
                                \State $r = m - 1$
                            \EndIf
                        \EndWhile
                        \State \Return{0}
                    \EndProcedure
                \end{algorithmic}
            \end{algorithm}
        \item \textbf{Asypmtotyka}
            Algorytm spełnia następująca rekurencje:
            \[
                T(n) = T(\frac{n}{2}) + \Theta(1)
            \]
            Rozwiązując za pomocą \textbf{Master Theorem} otrzymujemy:
            \[
                T(n) = \Theta(\log n)
            \]
\end{itemize}
\section{Ćwiczenia}
tu beda pojawialy sie notatki z cwiczen do przedmiotu Algorytmy i struktury danych na Politechnice Wrocławskiej na kierunku Informatyka Algorytmiczna rok 2025 semestr letni.

\subsection{Lista 2}
robiona na zajęciach \date{2025-03-10}
\subsubsection{zadanie 1}
Wylicz ile linijek wypisze poniższy program (podaj wynik będacy funkcją od n w postaci asymptotycznej $\Theta(\cdot)$). Można założyć, że $n$ jest potęgą liczby $3$.
\begin{algorithm}
\begin{algorithmic}[1]
\State \textbf{function} f(n)
\If{$n > 1$}
    \State print\_line('still going')
    \State f(n/3)
    \State f(n/3)
\EndIf
\end{algorithmic}
\end{algorithm}
w pseudo kodzie pojawia sie nastepujaca rekurencja:
\[
    T(n) = 2T(\frac{n}{3}) + 1
\]
rozwiąże ją używając metody podstawienia. Niech $n=3^k, k = \log_3 n$, wtedy:
\[
    T(3^k) = 2T(3^{k-1}) + 1
\]
Zatem przyjmując $S(k) = T(3^k)$ mamy:
\[
    S(k) = 2S(k-1) + 1
\]
rozwiązując rekurencję otrzymujemy:
\[
    S(k) = 2^k - 1
\]
zatem
\[
    T(n) = 2^{\log_3 n} - 1 = n^{\log_3 2} - 1 = \Theta(n^{\log_3 2})
\]
analogicznie liczmy jaka jest wykonana ``praca'' wykonana przez program w drzweie rekursji.

\subsubsection{zadanie 2}
Niech $f(n)$ i $g(n)$ będą funkcjami asymptotycznie nieujemnymi (tzn. nieujemnymi dla dostatecznie dużego $n$). Korzystając z definicji notacji $\Theta$, udowodnij, że:
\[
\max\{f(n), g(n)\} = \Theta(f(n) + g(n)).
\]
\begin{proof}
    Z definicji notacji $\Theta$ mamy:
    \[
        f(n)=\Theta(g(n)) \iff \exists c_1, c_2 > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n)
    \]
    skoro $f(n)$ i $g(n)$ są asymptotycznie nieujemne to:
    \[
        \exists n_f: \forall n \geq n_f, f(n) \geq 0
    \]
    \[
        \exists n_g: \forall n \geq n_g, g(n) \geq 0
    \]
    zatem
    \[
        n_0=\max\{n_f, n_g\}
    \]
    a więc
    \[
        f(n) \leq \max\{f(n), g(n)\}
    \]
    \[
        g(n) \leq \max\{f(n), g(n)\}
    \]
    dodając obie nierówności otrzymujemy:
    \[
        f(n) + g(n) \leq 2 \cdot \max\{f(n), g(n)\}
    \]
    zatem
    \[
        \forall n \geq n_0: \max\{f(n), g(n)\} \leq f(n) + g(n) \leq 2 \cdot \max\{f(n), g(n)\}
    \]
    a więc z definicji mamy
    \[
        \max\{f(n), g(n)\} = \Theta(f(n) + g(n))
    \]
\end{proof}

\subsubsection{zadanie 3}
Wylicz asymptotyczną złożoność (używając notacji $\Theta$) poniższych fragmentów programów:

\begin{algorithm}
\caption{Pierwszy fragment kodu}
\begin{algorithmic}[1]
\For{$i = 1$ to $n$}
    \State $j = i$
    \While{$j < n$}
        \State $sum = P(i, j)$
        \State $j = j + 1$
    \EndWhile
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Drugi fragment kodu}
\begin{algorithmic}[1]
\For{$i = 1$ to $n$}
    \State $j = i$
    \While{$j < n$}
        \State $sum = R(i, j)$
        \State $j = j + j$
    \EndWhile
\EndFor
\end{algorithmic}
\end{algorithm}
Gdzie:
\begin{itemize}
    \item koszt wykonania procedury $P(i,j)$ wynosi $\Theta(1)$,
    \item koszt wykonania procedury $R(i,j)$ wynosi $\Theta(j)$.
\end{itemize}

\begin{proof}
    \begin{itemize}
        \item Pierwszy fragment kodu
            \begin{itemize}
                \item Wewnętrzna pętla wykonuje się $n-i$ razy
                \item Koszt wykonania procedury $P(i,j)$ wynosi $\Theta(1)$
                \item Zatem koszt wykonania wewnętrznej pętli wynosi $\Theta(n-i)$
                \item Zatem koszt wykonania całego fragmentu wynosi
                    \[
                        \sum_{i=1}^{n} \Theta(n-i) = \Theta(n^2)
                    \]
            \end{itemize}
        \item Drugi fragment kodu
            \begin{itemize}
                \item Wewnętrzna pętla wykonuje się $\log_2 n$ razy
                \item Koszt wykonania procedury $R(i,j)$ wynosi $\Theta(j)$
                \item Zatem koszt wykonania wewnętrznej pętli wynosi $\Theta(\log_2 n)$
                \item Zatem koszt wykonania całego fragmentu wynosi
                    \[
                        \sum_{i=1}^{n} \Theta(\log_2 n) = \Theta(n \log_2 n)
                    \]
            \end{itemize}
    \end{itemize}
\end{proof}
Dla pewnosci sprawdzone empirycznie:
%zalacz wykres wykresAlgoZad3.png
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{wykresAlgoZad3.png}
\end{figure}

\subsubsection{zadanie 4}
Wyznacz asymptotyczne oszacowanie górne dla następujących rekurencji:

\begin{itemize}
    \item $T(n) = 2T(n/2) + 1$
    \item $T(n) = 2T(n/2) + n$
    \item $T(n) = 3T(n/2) + n \log n$
\end{itemize}

\bigskip
\hrule
\bigskip

Kożystając z \textbf{Master Theorem} możemy wyznaczyć ograniczenie dla tych rekurencji.
\begin{itemize}
    \item $T(n) = 2T(n/2) + 1$
        \begin{proof}
            \[
                a = 2, b = 2, d = 0
            \]
            \[
                \log_b a = \log_2 2 = 1 > 0 = d
            \]
            \[
                T(n) = \Theta(n)
            \]
        \end{proof}
    \item $T(n) = 2T(n/2) + n$
        \begin{proof}
            \[
                a = 2, b = 2, d = 1
            \]
            \[
                \log_b a = \log_2 2 = 1 = d
            \]
            \[
                T(n) = \Theta(n \log n)
            \]
        \end{proof}
    \item $T(n) = 3T(n/2) + n \log n$
        \begin{proof}
            \[
                a = 3, b = 2, d = 1
            \]
            \[
                \log_b a = \log_2 3 > 1 = d
            \]
            \[
                T(n) = \Theta(n^{\log_2 3})
            \]
        \end{proof}
\end{itemize}

\subsubsection{zadanie 5}
Zaprojektuj algorytm wczytujący z wejścia tablicę liczb $A[1], \ldots, A[N]$ i przygotowujący tablicę $B$ tak, że na jej podstawie będzie potrafił odpowiadać na pytania:
\begin{enumerate}
    \item ile wynosi suma elementów tablicy $A$ od miejsca $i$ do miejsca $j$ włącznie, dla $i < j$.
    \item Jaka jest złożoność czasowa Twojego algorytmu? Ile pamięci zajmuje tablica $B$?
    \item Ile zajmuje odpowiedź na jedno pytanie?
\end{enumerate}

\bigskip
\hrule
\bigskip

Przykładowy algorytm mógłby wyglądać następująco:
\begin{algorithm}
    \caption{Algorytm do zadania 5.}
    \begin{algorithmic}[1]
        \State $B[1] = A[1]$
        \For{$i = 2$ to $N$}
            \State $B[i] = B[i-1] + A[i]$
        \EndFor
        \Procedure{Sum}{i, j}
            \State \Return{$B[j] - B[i-1]$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

Co tu się dzieje?
\begin{itemize}
    \item W pierwszej pętli obliczamy sumy prefiksowe tablicy $A$ i zapisujemy je w tablicy $B$.
    \item W procedurze \texttt{Sum} zwracamy różnicę między dwoma elementami tablicy $B$.
\end{itemize}

\end{document}
